<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Yin Yang — Multi-Mode Spinner (Factory Loaded v3)</title>

<style>
  html, body {
    margin: 0;
    background: black;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, sans-serif;
    color: #ddd;
  }

  /* ----- BACKGROUND LAYERS ----- */
  #bgAurora, #bgShade {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  #bgAurora { z-index: 0; }
  #bgTunnel { z-index: 1; }
  #bgShade  { z-index: 2; }
  #stars    { z-index: 3; }
  #container{ z-index: 4; position: relative; }

  #bgAurora{
    opacity: 1;
    background:
      radial-gradient(1200px 900px at var(--ax1, 30%) var(--ay1, 35%),
        hsla(var(--ah1, 180), 100%, 55%, var(--aa1, 0.22)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 60%),
      radial-gradient(1000px 800px at var(--ax2, 70%) var(--ay2, 55%),
        hsla(var(--ah2, 260), 100%, 55%, var(--aa2, 0.18)) 0%,
        hsla(var(--ah1, 180), 100%, 50%, 0.00) 62%),
      radial-gradient(900px 700px at var(--ax3, 55%) var(--ay3, 25%),
        hsla(var(--ah3, 40), 100%, 55%, var(--aa3, 0.14)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 65%);
    mix-blend-mode: screen;
    will-change: background, filter;
  }

  /* Tunnel is a big centered square so effects never show “rectangle corners” */
  #bgTunnel{
    position: fixed;
    inset: auto;
    left: 50%;
    top: 45%;
    width: 180vmax;
    height: 180vmax;
    transform: translate(-50%, -50%);
    transform-origin: 50% 50%;
    pointer-events: none;

    opacity: 1;

    /*
      LAYER 1 (base): your original repeating radial lines (unchanged look)
      LAYER 2 (glow): a bright band that steps OUTER -> INNER to fake forward motion
      LAYER 3 (tail): a weaker trailing band for “afterglow”
    */
    background:
      radial-gradient(circle at var(--tcx, 50%) var(--tcy, 45%),
        hsla(var(--tg, 200), 100%, 70%, 0.00) calc((var(--gp, 88) - 6) * 1%),
        hsla(var(--tg, 200), 100%, 72%, var(--ga, 0.30)) calc((var(--gp, 88) + 0) * 1%),
        hsla(var(--tg, 200), 100%, 70%, 0.00) calc((var(--gp, 88) + 10) * 1%)
      ),
      radial-gradient(circle at var(--tcx, 50%) var(--tcy, 45%),
        hsla(var(--tg2, 210), 100%, 68%, 0.00) calc((var(--gp, 88) + var(--gt, 6) - 6) * 1%),
        hsla(var(--tg2, 210), 100%, 68%, var(--ga2, 0.12)) calc((var(--gp, 88) + var(--gt, 6) + 0) * 1%),
        hsla(var(--tg2, 210), 100%, 68%, 0.00) calc((var(--gp, 88) + var(--gt, 6) + 12) * 1%)
      ),
      repeating-radial-gradient(circle at var(--tcx, 50%) var(--tcy, 45%),
        hsla(var(--th1, 200), 100%, 55%, var(--ta, 0.10)) 0px,
        hsla(var(--th2, 320), 100%, 55%, var(--ta, 0.06)) 10px,
        hsla(var(--th1, 200), 100%, 55%, 0.00) 22px);

    mix-blend-mode: screen;
    will-change: background, filter, transform;
  }

  #bgShade{
    background: radial-gradient(circle at 50% 45%,
      rgba(0,0,0,0.05) 0%,
      rgba(0,0,0,0.65) 65%,
      rgba(0,0,0,0.95) 100%);
  }

  #stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    mix-blend-mode: screen;
  }

  /* ----- SPINNER ----- */
  #container {
    width: 420px;
    height: 420px;
  }

  @media (max-width: 520px) {
    #container { width: 320px; height: 320px; }
    #hud { bottom: -140px; }
    input[type="range"] { width: 210px; }
  }

  svg {
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
    transform-box: fill-box;
    will-change: transform, filter;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  #hud {
    position: absolute;
    bottom: -120px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    opacity: 0.88;
    user-select: none;
  }

  .row { margin-top: 6px; }
  input[type="range"] { width: 240px; }

  .small {
    font-size: 12px;
    opacity: 0.72;
    margin-top: 8px;
    line-height: 1.4;
  }

  kbd {
    background: #222;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 1px 5px;
  }

  .controls {
    display: inline-flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: #111;
    color: #ddd;
    border: 1px solid #444;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
  }

  button:active { transform: translateY(1px); }
  .paused { opacity: 0.6; }

  .cruiseOn {
    border-color: #888;
    box-shadow: 0 0 0 1px #666 inset;
  }
</style>
</head>

<body>

<canvas id="stars"></canvas>
<div id="bgAurora"></div>
<div id="bgTunnel"></div>
<div id="bgShade"></div>

<div id="container">
  <svg id="spinner" viewBox="-100 -100 200 200" aria-label="Yin Yang spinner" role="img">
    <defs>
      <filter id="warp" x="-30%" y="-30%" width="160%" height="160%">
        <feTurbulence id="turb" type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="2" />
        <feDisplacementMap id="disp" in="SourceGraphic" scale="0" />
      </filter>
    </defs>

    <g id="art">
      <circle id="outer" r="100" fill="white"/>

      <path id="half" d="
        M 0 -100
        A 100 100 0 0 1 0 100
        A 50 50 0 0 0 0 0
        A 50 50 0 0 1 0 -100
      " fill="black"/>

      <circle id="lobe1" cx="0" cy="-50" r="50" fill="white"/>
      <circle id="lobe2" cx="0" cy="50"  r="50" fill="black"/>

      <circle id="dot1" cx="0" cy="-42" r="14" fill="black"/>
      <circle id="dot2" cx="0" cy="42"  r="14" fill="white"/>
    </g>
  </svg>

  <div id="hud">
    <div>
      <strong>RPM:</strong>
      <span id="rpm">0.0</span>
      <span id="state"></span>
    </div>

    <div class="row">
      <input id="rpmSlider" type="range" min="0" max="600" step="1" value="0" />
      <span><strong>Target:</strong> <span id="rpmTarget">0</span></span>
    </div>

    <div class="controls">
      <button id="toggleBtn" type="button">Pause</button>
      <button id="resetBtn" type="button">Reset</button>
      <button id="brakeBtn" type="button">Brake</button>
      <button id="cruiseBtn" type="button">Cruise</button>
      <button id="modeBtn" type="button">Mode</button>
    </div>

    <div class="small">
      <strong>Mode:</strong> <span id="modeName"></span><br>
      <kbd>Space</kbd> start/stop · <kbd>↑</kbd>/<kbd>↓</kbd> speed · <kbd>R</kbd> reset ·
      <kbd>M</kbd> mode · <kbd>B</kbd> brake · <kbd>C</kbd> cruise<br>
      <span style="opacity:.8">
        <kbd>G</kbd> bg all · <kbd>A</kbd> aurora · <kbd>T</kbd> tunnel · <kbd>F</kbd> stars · <kbd>S</kbd> bg strobe
      </span>
    </div>
  </div>
</div>

<script>
  const spinner = document.getElementById("spinner");
  const art = document.getElementById("art");

  const outer = document.getElementById("outer");
  const half  = document.getElementById("half");
  const lobe1 = document.getElementById("lobe1");
  const lobe2 = document.getElementById("lobe2");
  const dot1  = document.getElementById("dot1");
  const dot2  = document.getElementById("dot2");

  const turb = document.getElementById("turb");
  const disp = document.getElementById("disp");

  const rpmEl = document.getElementById("rpm");
  const stateEl = document.getElementById("state");
  const slider = document.getElementById("rpmSlider");
  const rpmTargetEl = document.getElementById("rpmTarget");

  const toggleBtn = document.getElementById("toggleBtn");
  const resetBtn = document.getElementById("resetBtn");
  const brakeBtn = document.getElementById("brakeBtn");
  const cruiseBtn = document.getElementById("cruiseBtn");
  const modeBtn = document.getElementById("modeBtn");
  const modeNameEl = document.getElementById("modeName");

  const bgAurora = document.getElementById("bgAurora");
  const bgTunnel = document.getElementById("bgTunnel");
  const stars = document.getElementById("stars");
  const ctx = stars.getContext("2d", { alpha: true });

  // ----- STATE -----
  let angle = 0;
  let speed = 0;           // deg/sec
  let running = true;

  let targetRPM = 0;
  let autoRamp = true;
  let cruiseOn = false;

  let last = performance.now();
  let hue = 0;
  let t = 0;

  const steps = 24;
  const stepSize = 360 / steps;

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
  function rpmToDeg(rpm) { return rpm * 6; }
  const MAX_RPM = 600;

  // Intensity
  const INT = 0.75;

  // ----- UI THROTTLE / CACHES -----
  let uiLastWrite = 0;
  let lastShownRPM = "";
  let lastShownTarget = "";
  let lastSlider = -1;

  function writeTargetUI(rpm) {
    const rounded = Math.round(rpm);
    if (rounded !== lastSlider) {
      slider.value = String(rounded);
      lastSlider = rounded;
    }
    const s = String(rounded);
    if (s !== lastShownTarget) {
      rpmTargetEl.textContent = s;
      lastShownTarget = s;
    }
  }

  function writeRPMUI(rpmFloat) {
    const s = rpmFloat.toFixed(1);
    if (s !== lastShownRPM) {
      rpmEl.textContent = s;
      lastShownRPM = s;
    }
  }

  function updateColors() {
    outer.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
    half.setAttribute("fill", `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    lobe1.setAttribute("fill", `hsl(${((hue+90)%360+360)%360},100%,60%)`);
    lobe2.setAttribute("fill", `hsl(${((hue+270)%360+360)%360},100%,60%)`);
    dot1.setAttribute("fill", `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    dot2.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
  }

  function classicColors() {
    outer.setAttribute("fill", "white");
    half.setAttribute("fill", "black");
    lobe1.setAttribute("fill", "white");
    lobe2.setAttribute("fill", "black");
    dot1.setAttribute("fill", "black");
    dot2.setAttribute("fill", "white");
  }

  function setDotStroke(on) {
    if (on) {
      dot1.setAttribute("stroke", "white");
      dot1.setAttribute("stroke-width", "2");
      dot2.setAttribute("stroke", "black");
      dot2.setAttribute("stroke-width", "2");
    } else {
      dot1.removeAttribute("stroke");
      dot1.removeAttribute("stroke-width");
      dot2.removeAttribute("stroke");
      dot2.removeAttribute("stroke-width");
    }
  }

  function setRunning(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? "Pause" : "Start";
    stateEl.textContent = running ? "" : " (paused)";
    rpmEl.classList.toggle("paused", !running);
  }

  function setTargetRPM(rpm) {
    targetRPM = clamp(rpm, 0, MAX_RPM);
  }

  function setCruiseUI(on) {
    cruiseOn = on;
    cruiseBtn.classList.toggle("cruiseOn", on);
    cruiseBtn.textContent = on ? "Cruise: On" : "Cruise";
  }

  function cancelCruise() { if (cruiseOn) setCruiseUI(false); }

  function brake() {
    autoRamp = false;
    cancelCruise();
    setRunning(true);
    setTargetRPM(0);
  }

  function cruise() {
    if (!cruiseOn) {
      autoRamp = false;
      const currentRPM = speed / 6;
      setTargetRPM(Math.round(currentRPM));
      setCruiseUI(true);
    } else {
      setCruiseUI(false);
      autoRamp = true;
    }
  }

  function clearTrippyFX() {
    art.removeAttribute("filter");
    spinner.style.filter = "";
    spinner.style.mixBlendMode = "";
    spinner.style.transformOrigin = "50% 50%";
  }

  function resetAll() {
    angle = 0;
    speed = 0;
    hue = 0;
    t = 0;
    spinner.style.transform = "rotate(0deg)";

    autoRamp = true;
    cancelCruise();

    setRunning(true);
    setTargetRPM(0);

    modes[modeIndex].onEnter?.();

    writeTargetUI(targetRPM);
    writeRPMUI(0);

    // reset tunnel chase
    glowPos = 0;
    glowAcc = 0;
  }

  // ----- SPINNER MODES -----
  let modeIndex = 1;
  const modes = [
    { name: "Classic (B/W)", onEnter(){ clearTrippyFX(); setDotStroke(false); classicColors(); }, update(dt){} },
    {
      name: "Indexed Color (Stepped)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        hue = Math.round(hue / stepSize) * stepSize;
        updateColors();
      }
    },
    {
      name: "Outlined Eyes (Smooth Hue)",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); },
      update(dt){ hue += (speed * 0.02 * dt); updateColors(); }
    },
    {
      name: "Neon Glow Pulse",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); spinner.style.mixBlendMode = "screen"; },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const pulse = 0.5 + 0.5 * Math.sin(t * 2.2);
        const glow = clamp((rpm / 600) * 18 + pulse * 8, 0, 28);
        spinner.style.filter = `drop-shadow(0 0 ${glow.toFixed(1)}px hsl(${(hue%360+360)%360},100%,60%))`;
      }
    },
    {
      name: "Warp Field (Liquid)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); art.setAttribute("filter","url(#warp)"); },
      update(dt){
        hue += (speed * 0.018 * dt);
        updateColors();
        const rpm = speed / 6;
        const energy = rpm / 600;
        const wobble = 0.5 + 0.5 * Math.sin(t * 1.7);
        const bf = 0.010 + 0.012 * (0.35 + wobble) * energy;
        turb.setAttribute("baseFrequency", bf.toFixed(4));
        const scale = 2 + 28 * energy * (0.35 + wobble);
        disp.setAttribute("scale", scale.toFixed(1));
      }
    },
    {
      name: "Strobe Invert (Beat)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const beatHz = 2 + 10 * (rpm / 600);
        const strobe = (Math.sin(t * Math.PI * 2 * beatHz) > 0.4);
        const wob = 1 + 0.012 * Math.sin(t * 3.3);
        spinner.style.filter = strobe ? "invert(1) contrast(1.15)" : "contrast(1.05)";
        spinner.style.transform = `rotate(${angle}deg) scale(${wob.toFixed(4)})`;
      }
    }
  ];

  function applyMode(i) {
    modeIndex = (i + modes.length) % modes.length;
    modeNameEl.textContent = modes[modeIndex].name;
    modes[modeIndex].onEnter?.();
  }
  function nextMode(){ applyMode(modeIndex + 1); }

  // ----- BACKGROUND SYSTEM -----
  let bgOn = true;
  let bgAuroraOn = true;
  let bgTunnelOn = true;
  let bgStarsOn = true;
  let bgStrobe = true;

  let bgLastWrite = 0;
  let bgPhase = 0;

  // --- Tunnel “forward motion” chase ---
  // glowPos is a float position [0..GLOW_STEPS)
  let glowPos = 0;
  let glowAcc = 0;
  const GLOW_STEPS = 30;             // how many “rings” in the chase illusion (more = smoother)
  const GLOW_PER_REV = GLOW_STEPS;   // one full chase per rotation (synced to RPM)

  // Starfield
  let W = 0, H = 0, DPR = 1;
  let starsList = [];

  function resizeStars() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    stars.width = Math.floor(W * DPR);
    stars.height = Math.floor(H * DPR);
    stars.style.width = W + "px";
    stars.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    const base = Math.floor((W * H) / 9000);
    const count = clamp(Math.floor(base * 1.9), 220, 620);

    starsList = [];
    for (let i = 0; i < count; i++) {
      starsList.push({
        x: Math.random() * W,
        y: Math.random() * H,
        z: Math.random(),
        r: 0.25 + Math.random() * 0.60,
        tw: Math.random() * Math.PI * 2
      });
    }
  }
  window.addEventListener("resize", resizeStars);

  function updateBackground(dt, now) {
    if (!bgOn) {
      bgAurora.style.opacity = "0";
      bgTunnel.style.opacity = "0";
      ctx.clearRect(0, 0, W, H);
      return;
    }

    const rpm = speed / 6;
    const energy = clamp(rpm / 600, 0, 1);
    const e = energy * INT;

    // advance tunnel chase (outer -> inner) synced to rpm
    // RPM -> rotations per second = rpm/60
    // steps per second = (rpm/60) * GLOW_PER_REV
    const sps = (rpm / 60) * GLOW_PER_REV;
    glowPos = (glowPos + sps * dt) % GLOW_STEPS;

    if (now - bgLastWrite > 50) {
      bgLastWrite = now;

      const rate = 0.10 + 1.15 * e;
      bgPhase += dt * rate;
      const tri = 1 - Math.abs(((bgPhase % 1) * 2) - 1);

      let pop = 0;
      if (bgStrobe) {
        const beatHz = 1.2 + 10.5 * e;
        const st = Math.sin(t * Math.PI * 2 * beatHz);
        pop = Math.max(0, (st - 0.65) / 0.35);
        pop = pop * pop;
      }

      if (bgAuroraOn) {
        const base = (hue + 30 + t * 8) % 360;
        const ah1 = base + 220 * tri;
        const ah2 = base + 180 - 220 * tri;
        const ah3 = base + 90 + 120 * (1 - tri);

        const aa1 = (0.10 + 0.28 * e) + pop * 0.14;
        const aa2 = (0.08 + 0.22 * e) + pop * 0.12;
        const aa3 = (0.06 + 0.18 * e) + pop * 0.10;

        const ax1 = 25 + 18 * Math.sin(t * (0.22 + 0.5 * e));
        const ay1 = 35 + 10 * Math.cos(t * (0.18 + 0.4 * e));
        const ax2 = 70 + 15 * Math.cos(t * (0.17 + 0.55 * e));
        const ay2 = 55 + 12 * Math.sin(t * (0.20 + 0.35 * e));
        const ax3 = 55 + 22 * Math.sin(t * (0.14 + 0.45 * e));
        const ay3 = 25 + 16 * Math.cos(t * (0.16 + 0.42 * e));

        bgAurora.style.opacity = "1";
        bgAurora.style.setProperty("--ah1", ah1.toFixed(1));
        bgAurora.style.setProperty("--ah2", ah2.toFixed(1));
        bgAurora.style.setProperty("--ah3", ah3.toFixed(1));
        bgAurora.style.setProperty("--aa1", aa1.toFixed(3));
        bgAurora.style.setProperty("--aa2", aa2.toFixed(3));
        bgAurora.style.setProperty("--aa3", aa3.toFixed(3));
        bgAurora.style.setProperty("--ax1", ax1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay1", ay1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax2", ax2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay2", ay2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax3", ax3.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay3", ay3.toFixed(1) + "%");
      } else {
        bgAurora.style.opacity = "0";
      }

      if (bgTunnelOn) {
        const th1 = (hue + 40 + 180 * tri) % 360;
        const th2 = (hue + 220 - 180 * tri) % 360;
        const ta = (0.03 + 0.12 * e) + pop * 0.08;

        const tcx = 50 + 2.6 * Math.sin(t * (0.55 + 0.9 * e));
        const tcy = 45 + 2.1 * Math.cos(t * (0.48 + 0.8 * e));

        // glow band position: OUTER -> INNER
        // glowPos goes 0..GLOW_STEPS; map to percent 92% -> 8% (avoid extremes)
        const gi = Math.floor(glowPos);
        const pct = 92 - (gi / (GLOW_STEPS - 1)) * 84;

        // glow alpha tied to energy + strobe pop
        const ga  = (0.10 + 0.35 * e) + pop * 0.20;
        const ga2 = (0.05 + 0.18 * e) + pop * 0.10;

        bgTunnel.style.opacity = "1";
        bgTunnel.style.setProperty("--th1", th1.toFixed(1));
        bgTunnel.style.setProperty("--th2", th2.toFixed(1));
        bgTunnel.style.setProperty("--ta", ta.toFixed(3));
        bgTunnel.style.setProperty("--tcx", tcx.toFixed(2) + "%");
        bgTunnel.style.setProperty("--tcy", tcy.toFixed(2) + "%");

        // glow vars
        bgTunnel.style.setProperty("--gp", pct.toFixed(2));
        bgTunnel.style.setProperty("--gt", (100 / GLOW_STEPS).toFixed(2)); // tail spacing
        bgTunnel.style.setProperty("--tg",  (th1).toFixed(1));
        bgTunnel.style.setProperty("--tg2", (th2).toFixed(1));
        bgTunnel.style.setProperty("--ga",  ga.toFixed(3));
        bgTunnel.style.setProperty("--ga2", ga2.toFixed(3));
      } else {
        bgTunnel.style.opacity = "0";
      }

      const bright = 1 + 0.85 * pop;
      if (bgAuroraOn) bgAurora.style.filter = `saturate(1.2) contrast(1.05) brightness(${bright.toFixed(2)})`;
      if (bgTunnelOn) bgTunnel.style.filter = `saturate(1.25) contrast(1.10) brightness(${bright.toFixed(2)})`;
    }

    // IMPORTANT CHANGE:
    // tunnel no longer rotates — only gentle “swell” based on energy
    if (bgTunnelOn) {
      const swell = 1 + 0.06 * (energy * INT);
      bgTunnel.style.transform = `translate(-50%, -50%) scale(${swell.toFixed(4)})`;
    } else {
      bgTunnel.style.transform = "translate(-50%, -50%)";
    }

    if (bgStarsOn) {
      ctx.fillStyle = "rgba(0,0,0,0.16)";
      ctx.fillRect(0, 0, W, H);

      const cx = W * 0.5;
      const cy = H * 0.45;

      const breathe = 0.6 + 0.4 * Math.sin(t * 1.2);

      const accel = (0.6 + 7.0 * (energy * energy) + 8.0 * (energy * energy * energy)) * INT;
      const warp = accel * breathe;

      for (const s of starsList) {
        s.tw += dt * (0.9 + 2.4 * energy) * (0.6 + s.z);
        const twinkle = 0.60 + 0.40 * Math.sin(s.tw);

        const dx = s.x - cx;
        const dy = s.y - cy;

        const swirl = 0.0040 * warp;
        const rx = dx * Math.cos(swirl) - dy * Math.sin(swirl);
        const ry = dx * Math.sin(swirl) + dy * Math.cos(swirl);

        const denom = (160 + 520 * s.z);
        const push = (warp * 220) * dt;
        s.x += (rx / denom) * push;
        s.y += (ry / denom) * push;

        if (s.x < -12) s.x = W + 12;
        if (s.x > W + 12) s.x = -12;
        if (s.y < -12) s.y = H + 12;
        if (s.y > H + 12) s.y = -12;

        const size  = s.r * (0.55 + 0.65 * (energy * INT)) * (0.85 + 0.55 * twinkle);
        const alpha = (0.10 + 0.35 * (energy * INT)) * (0.55 + 0.70 * twinkle);

        const hh = (hue + 110 * (s.z - 0.5)) % 360;
        ctx.fillStyle = `hsla(${(hh+360)%360}, 100%, 78%, 1)`;

        ctx.globalAlpha = Math.min(1, alpha * 0.45);
        ctx.beginPath();
        ctx.arc(s.x, s.y, size * 1.55, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = Math.min(1, alpha);
        ctx.beginPath();
        ctx.arc(s.x, s.y, Math.max(0.35, size * 0.60), 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
      }
    } else {
      ctx.clearRect(0, 0, W, H);
    }
  }

  // ----- UI EVENTS -----
  slider.addEventListener("input", () => {
    cancelCruise();
    autoRamp = false;
    setTargetRPM(Number(slider.value));
    writeTargetUI(targetRPM);
  });

  toggleBtn.addEventListener("click", () => setRunning(!running));
  resetBtn.addEventListener("click", resetAll);
  brakeBtn.addEventListener("click", brake);
  cruiseBtn.addEventListener("click", cruise);
  modeBtn.addEventListener("click", nextMode);

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") { e.preventDefault(); setRunning(!running); return; }
    if (e.key === "m" || e.key === "M") { nextMode(); return; }
    if (e.key === "r" || e.key === "R") { resetAll(); return; }
    if (e.key === "b" || e.key === "B") { brake(); return; }
    if (e.key === "c" || e.key === "C") { cruise(); return; }

    if (e.key === "g" || e.key === "G") { bgOn = !bgOn; return; }
    if (e.key === "a" || e.key === "A") { bgAuroraOn = !bgAuroraOn; return; }
    if (e.key === "t" || e.key === "T") { bgTunnelOn = !bgTunnelOn; return; }
    if (e.key === "f" || e.key === "F") { bgStarsOn = !bgStarsOn; return; }
    if (e.key === "s" || e.key === "S") { bgStrobe = !bgStrobe; return; }

    if (e.key === "ArrowUp") { cancelCruise(); autoRamp = false; setTargetRPM(targetRPM + 5); writeTargetUI(targetRPM); return; }
    if (e.key === "ArrowDown") { cancelCruise(); autoRamp = false; setTargetRPM(targetRPM - 5); writeTargetUI(targetRPM); return; }
  });

  // ----- ANIMATION LOOP -----
  function tick(now) {
    const dt = (now - last) / 1000;
    last = now;
    t += dt;

    if (running) {
      if (autoRamp) {
        cancelCruise();
        const rampRate = MAX_RPM / 10;
        setTargetRPM(targetRPM + rampRate * dt);
        if (targetRPM >= MAX_RPM) autoRamp = false;
      }

      const targetSpeed = rpmToDeg(targetRPM);

      const accel = 360;
      const decel = 900;
      const maxAccel = (targetSpeed < speed) ? decel : accel;

      const delta = targetSpeed - speed;
      const step = Math.sign(delta) * Math.min(Math.abs(delta), maxAccel * dt);
      speed += step;

      angle = (angle + speed * dt) % 360;

      if (modes[modeIndex].name !== "Strobe Invert (Beat)") {
        spinner.style.transform = `rotate(${angle}deg)`;
      }

      writeRPMUI(speed / 6);
      modes[modeIndex].update?.(dt);
    }

    updateBackground(dt, now);

    if (now - uiLastWrite > 50) {
      uiLastWrite = now;
      writeTargetUI(targetRPM);
    }

    requestAnimationFrame(tick);
  }

  // init
  applyMode(modeIndex);
  resizeStars();
  resetAll();
  requestAnimationFrame(tick);
</script>

</body>
</html>
