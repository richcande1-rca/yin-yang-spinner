<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flowing Starfield (No Loop)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #05070b; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
    #hud {
      position: fixed; left: 12px; top: 12px;
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(0,0,0,.45); border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px; border-radius: 12px;
      user-select: none;
      backdrop-filter: blur(6px);
    }
    #hud b { font-weight: 650; }
    #hud .row { display:flex; align-items:center; gap:8px; margin-top: 6px; }
    #hud input[type="range"] { width: 180px; }
    #hud button {
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      color: #e8eefc;
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
    }
    #hud button:active { transform: translateY(1px); }
    #hud .dim { opacity:.85; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div><b>Flowing Starfield</b> <span class="dim">(no repeating loop)</span></div>
  <div class="row">
    <span class="dim">Stars</span>
    <input id="stars" type="range" min="200" max="6000" step="50" value="1600">
    <span id="starsVal">1600</span>
  </div>
  <div class="row">
    <span class="dim">Speed</span>
    <input id="speed" type="range" min="10" max="900" step="5" value="220">
    <span id="speedVal">220</span>
  </div>
  <div class="row">
    <span class="dim">Warp</span>
    <input id="warp" type="range" min="0" max="1" step="0.01" value="0.12">
    <span id="warpVal">0.12</span>
  </div>
  <div class="row">
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
    <span class="dim" style="margin-left:auto">Keys: ↑↓ speed, +/- stars</span>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  // HUD
  const starsSlider = document.getElementById('stars');
  const speedSlider = document.getElementById('speed');
  const warpSlider  = document.getElementById('warp');
  const starsVal = document.getElementById('starsVal');
  const speedVal = document.getElementById('speedVal');
  const warpVal  = document.getElementById('warpVal');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  // Internal state
  let W = 1, H = 1, DPR = 1;
  let paused = false;

  // Camera-ish parameters
  let baseSpeed = +speedSlider.value;  // pixels/sec-ish (after perspective)
  let warp = +warpSlider.value;        // 0..1 curvature/streaming
  let targetCount = +starsSlider.value;

  // Stars live in a 3D-ish box in front of camera, projected to screen.
  // z in (0..1], smaller is "closer" (faster, brighter).
  let stars = [];
  let lastT = performance.now();

  // Util
  const rand = (a, b) => a + Math.random() * (b - a);
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

  function resize() {
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  function makeStar(spawnEdge = false) {
    // x,y are in screen-centered "world" coords, z depth in (0..1]
    // If spawnEdge, start slightly outside view to avoid popping.
    const margin = spawnEdge ? 1.2 : 1.0;
    const x = rand(-W*0.5*margin, W*0.5*margin);
    const y = rand(-H*0.5*margin, H*0.5*margin);
    const z = Math.pow(Math.random(), 1.8) * 0.98 + 0.02; // bias toward far stars
    // Small per-star variation so the field never "settles" into repetition
    const drift = rand(-0.15, 0.15);     // sideways drift factor
    const tw = rand(0.7, 1.3);           // twinkle rate factor
    const seed = Math.random() * 1000;   // unique phase seed
    return { x, y, z, drift, tw, seed };
  }

  function resetStars() {
    stars = [];
    for (let i = 0; i < targetCount; i++) stars.push(makeStar());
  }

  // Maintain target star count without nuking the whole scene.
  function adjustCount() {
    const n = targetCount;
    if (stars.length < n) {
      for (let i = stars.length; i < n; i++) stars.push(makeStar(true));
    } else if (stars.length > n) {
      stars.length = n;
    }
  }

  resetStars();

  // Controls
  starsSlider.addEventListener('input', () => {
    targetCount = +starsSlider.value;
    starsVal.textContent = targetCount;
    adjustCount();
  });
  speedSlider.addEventListener('input', () => {
    baseSpeed = +speedSlider.value;
    speedVal.textContent = baseSpeed;
  });
  warpSlider.addEventListener('input', () => {
    warp = +warpSlider.value;
    warpVal.textContent = warp.toFixed(2);
  });

  pauseBtn.addEventListener('click', () => {
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  });

  resetBtn.addEventListener('click', () => {
    resetStars();
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') { paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; }
    if (e.key === 'ArrowUp') { baseSpeed = clamp(baseSpeed + 15, 10, 900); speedSlider.value = baseSpeed; speedVal.textContent = baseSpeed; }
    if (e.key === 'ArrowDown') { baseSpeed = clamp(baseSpeed - 15, 10, 900); speedSlider.value = baseSpeed; speedVal.textContent = baseSpeed; }
    if (e.key === '+' || e.key === '=') { targetCount = clamp(targetCount + 100, 200, 6000); starsSlider.value = targetCount; starsVal.textContent = targetCount; adjustCount(); }
    if (e.key === '-' || e.key === '_') { targetCount = clamp(targetCount - 100, 200, 6000); starsSlider.value = targetCount; starsVal.textContent = targetCount; adjustCount(); }
  }, { passive: true });

  function project(star) {
    // Perspective: scale based on z.
    // z small => close => bigger movement & brightness.
    const fov = 0.9; // tweak: higher = more spread
    const invZ = 1.0 / star.z;
    const sx = (star.x * invZ * fov) + W * 0.5;
    const sy = (star.y * invZ * fov) + H * 0.5;
    return { sx, sy, invZ };
  }

  function step(dt, tNow) {
    // dt in seconds
    // Important: NO MODULO on time. Ever-increasing time kills loops.
    const t = tNow * 0.001;

    // Fade background slightly for subtle trailing (optional).
    // If you want crisp stars only, set alpha to 1.
    ctx.fillStyle = 'rgba(5,7,11,0.35)';
    ctx.fillRect(0, 0, W, H);

    ctx.beginPath();

    // Warp controls: a little radial pull so stars "stream"
    // but not enough to feel like a repeating tunnel.
    const warpAmt = warp;

    for (let i = 0; i < stars.length; i++) {
      const s = stars[i];

      // Speed scales with depth (closer = faster).
      const depthSpeed = baseSpeed * (0.25 + (1.2 / s.z));

      // Forward motion: move outward from center (like flying through stars)
      // We simulate "camera moving forward" by increasing x/y magnitude slowly
      // and recycling when out of bounds.
      const ax = s.x;
      const ay = s.y;

      // A touch of curved flow (warp) + unique drift so no cycle emerges.
      const swirl = Math.sin((t * 0.8 + s.seed) * s.tw) * s.drift;

      // Update position (time-based!)
      s.x += (ax * 0.0008 * depthSpeed) * dt + swirl * 12 * dt;
      s.y += (ay * 0.0008 * depthSpeed) * dt - swirl * 10 * dt;

      // Also make them "approach" by decreasing z over time (bigger + faster)
      // When z too small, recycle to far.
      s.z -= (0.18 + 0.9 / (1 + s.z * 8)) * dt * 0.22;

      // Tiny stochastic drift to prevent ever syncing (anti-loop)
      // (small enough to be invisible, big enough to break repetition)
      s.z *= 1 + (Math.random() - 0.5) * 0.00035;

      // Recycle star if it leaves view or gets too close
      const p = project(s);
      const out = (p.sx < -50 || p.sx > W + 50 || p.sy < -50 || p.sy > H + 50 || s.z <= 0.02);

      if (out) {
        // Respawn far with fresh x/y near center-ish to avoid edge clumps
        // IMPORTANT: recycle ONE star, not all — this prevents looping.
        const ns = makeStar(true);
        // spawn near center to keep "flight" look
        ns.x = rand(-W*0.15, W*0.15);
        ns.y = rand(-H*0.15, H*0.15);
        ns.z = rand(0.75, 1.0);
        stars[i] = ns;
        continue;
      }

      // Draw
      // Brightness based on depth + slight twinkle
      const twinkle = 0.85 + 0.15 * Math.sin((t * 2.2 + s.seed) * s.tw);
      const b = clamp((1.2 / s.z) * 0.12, 0.08, 1.0) * twinkle;

      // Size based on invZ, but clamped to keep it tasteful
      const r = clamp(p.invZ * 0.55, 0.6, 2.4);

      // Optional short streaking with speed
      const streak = warpAmt * clamp(depthSpeed / 900, 0, 1) * (1.0 / s.z) * 0.7;
      const dx = (p.sx - W*0.5);
      const dy = (p.sy - H*0.5);
      const len = clamp(Math.hypot(dx, dy) * 0.003 * streak, 0, 10);

      // Color: mostly white/blue-ish, slight variation
      const cool = clamp(0.75 + (1 - s.z) * 0.35, 0.75, 1.0);
      const rr = Math.floor(220 * b);
      const gg = Math.floor(235 * b);
      const bb = Math.floor(255 * b * cool);

      // Draw as a small streak line (or dot if len small)
      if (len > 0.6) {
        const nx = dx / (Math.hypot(dx, dy) + 1e-6);
        const ny = dy / (Math.hypot(dx, dy) + 1e-6);
        ctx.strokeStyle = `rgba(${rr},${gg},${bb},${clamp(b, 0.10, 1.0)})`;
        ctx.lineWidth = r;
        ctx.beginPath();
        ctx.moveTo(p.sx, p.sy);
        ctx.lineTo(p.sx - nx * len, p.sy - ny * len);
        ctx.stroke();
      } else {
        ctx.fillStyle = `rgba(${rr},${gg},${bb},${clamp(b, 0.12, 1.0)})`;
        ctx.beginPath();
        ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  function animate(now) {
    const dt = (now - lastT) * 0.001;
    lastT = now;

    if (!paused) {
      // Cap dt so it doesn't explode if tab was inactive.
      step(Math.min(dt, 0.05), now);
    }

    requestAnimationFrame(animate);
  }

  // Start with a clean frame (no trails for first draw)
  ctx.fillStyle = '#05070b';
  ctx.fillRect(0, 0, W, H);

  requestAnimationFrame((t) => {
    lastT = t;
    requestAnimationFrame(animate);
  });
})();
</script>
</body>
</html>
