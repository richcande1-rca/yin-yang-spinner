<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Yin Yang — Multi-Mode Spinner</title>

<style>
  html, body {
    margin: 0;
    background: black;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, sans-serif;
    color: #ddd;
  }

  #container {
    position: relative;
    width: 420px;
    height: 420px;
  }

  @media (max-width: 520px) {
    #container { width: 320px; height: 320px; }
    #hud { bottom: -140px; }
    input[type="range"] { width: 210px; }
  }

  svg {
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
    transform-box: fill-box;
    will-change: transform;
  }

  #hud {
    position: absolute;
    bottom: -120px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    opacity: 0.88;
    user-select: none;
  }

  .row { margin-top: 6px; }

  input[type="range"] { width: 240px; }

  .small {
    font-size: 12px;
    opacity: 0.72;
    margin-top: 8px;
    line-height: 1.4;
  }

  kbd {
    background: #222;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 1px 5px;
  }

  .controls {
    display: inline-flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: #111;
    color: #ddd;
    border: 1px solid #444;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
  }

  button:active { transform: translateY(1px); }

  .paused { opacity: 0.6; }

  .cruiseOn {
    border-color: #888;
    box-shadow: 0 0 0 1px #666 inset;
  }
</style>
</head>

<body>
<div id="container">

  <svg id="spinner" viewBox="-100 -100 200 200" aria-label="Yin Yang spinner" role="img">
    <circle id="outer" r="100" fill="white"/>

    <path id="half" d="
      M 0 -100
      A 100 100 0 0 1 0 100
      A 50 50 0 0 0 0 0
      A 50 50 0 0 1 0 -100
    " fill="black"/>

    <circle id="lobe1" cx="0" cy="-50" r="50" fill="white"/>
    <circle id="lobe2" cx="0" cy="50"  r="50" fill="black"/>

    <circle id="dot1" cx="0" cy="-42" r="14" fill="black"/>
    <circle id="dot2" cx="0" cy="42"  r="14" fill="white"/>
  </svg>

  <div id="hud">
    <div>
      <strong>RPM:</strong>
      <span id="rpm">0.0</span>
      <span id="state"></span>
    </div>

    <div class="row">
      <input id="rpmSlider" type="range" min="0" max="600" step="1" value="0" />
      <span><strong>Target:</strong> <span id="rpmTarget">0</span></span>
    </div>

    <div class="controls">
      <button id="toggleBtn" type="button">Pause</button>
      <button id="resetBtn" type="button">Reset</button>
      <button id="brakeBtn" type="button">Brake</button>
      <button id="cruiseBtn" type="button">Cruise</button>
      <button id="modeBtn" type="button">Mode</button>
    </div>

    <div class="small">
      <strong>Mode:</strong> <span id="modeName"></span><br>
      <kbd>Space</kbd> start/stop · <kbd>↑</kbd>/<kbd>↓</kbd> speed · <kbd>R</kbd> reset ·
      <kbd>M</kbd> mode · <kbd>B</kbd> brake · <kbd>C</kbd> cruise
    </div>
  </div>

</div>

<script>
  const spinner = document.getElementById("spinner");

  const outer = document.getElementById("outer");
  const half  = document.getElementById("half");
  const lobe1 = document.getElementById("lobe1");
  const lobe2 = document.getElementById("lobe2");
  const dot1  = document.getElementById("dot1");
  const dot2  = document.getElementById("dot2");

  const rpmEl = document.getElementById("rpm");
  const stateEl = document.getElementById("state");
  const slider = document.getElementById("rpmSlider");
  const rpmTargetEl = document.getElementById("rpmTarget");

  const toggleBtn = document.getElementById("toggleBtn");
  const resetBtn = document.getElementById("resetBtn");
  const brakeBtn = document.getElementById("brakeBtn");
  const cruiseBtn = document.getElementById("cruiseBtn");
  const modeBtn = document.getElementById("modeBtn");
  const modeNameEl = document.getElementById("modeName");

  let angle = 0;           // degrees
  let speed = 0;           // deg/sec (actual)
  let running = true;

  let targetRPM = 0;       // desired
  let autoRamp = true;     // ramps targetRPM upward to max
  let cruiseOn = false;    // locks current RPM; pressing again resumes autoRamp

  let last = performance.now();
  let hue = 0;

  const steps = 24;
  const stepSize = 360 / steps;

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
  function rpmToDeg(rpm) { return rpm * 6; } // 1 RPM = 6 deg/sec

  function hsl(h) {
    return `hsl(${(h % 360 + 360) % 360},100%,60%)`;
  }

  function updateColors() {
    outer.setAttribute("fill", hsl(hue));
    half.setAttribute("fill", hsl(hue + 180));
    lobe1.setAttribute("fill", hsl(hue + 90));
    lobe2.setAttribute("fill", hsl(hue + 270));
    dot1.setAttribute("fill", hsl(hue + 180));
    dot2.setAttribute("fill", hsl(hue));
  }

  function classicColors() {
    outer.setAttribute("fill", "white");
    half.setAttribute("fill", "black");
    lobe1.setAttribute("fill", "white");
    lobe2.setAttribute("fill", "black");
    dot1.setAttribute("fill", "black");
    dot2.setAttribute("fill", "white");
  }

  function setDotStroke(on) {
    if (on) {
      dot1.setAttribute("stroke", "white");
      dot1.setAttribute("stroke-width", "2");
      dot2.setAttribute("stroke", "black");
      dot2.setAttribute("stroke-width", "2");
    } else {
      dot1.removeAttribute("stroke");
      dot1.removeAttribute("stroke-width");
      dot2.removeAttribute("stroke");
      dot2.removeAttribute("stroke-width");
    }
  }

  function setRunning(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? "Pause" : "Start";
    stateEl.textContent = running ? "" : " (paused)";
    rpmEl.classList.toggle("paused", !running);
  }

  function setTargetRPM(rpm) {
    targetRPM = clamp(rpm, 0, 600);
    slider.value = String(Math.round(targetRPM));
    rpmTargetEl.textContent = String(Math.round(targetRPM));
  }

  function setCruiseUI(on) {
    cruiseOn = on;
    cruiseBtn.classList.toggle("cruiseOn", on);
    cruiseBtn.textContent = on ? "Cruise: On" : "Cruise";
  }

  function cancelCruise() {
    if (cruiseOn) setCruiseUI(false);
  }

  function brake() {
    autoRamp = false;
    cancelCruise();
    setRunning(true);
    setTargetRPM(0); // spools down over the accel limit
  }

  function cruise() {
    if (!cruiseOn) {
      // Engage cruise: lock current RPM
      autoRamp = false;
      const currentRPM = speed / 6;
      setTargetRPM(Math.round(currentRPM));
      setCruiseUI(true);
    } else {
      // Disengage cruise: resume auto ramp
      setCruiseUI(false);
      autoRamp = true;
    }
  }

  function resetAll() {
    // True reboot: zero state then auto-ramp from 0 -> max
    angle = 0;
    speed = 0;
    hue = 0;
    spinner.style.transform = "rotate(0deg)";

    autoRamp = true;
    cancelCruise();

    setRunning(true);
    setTargetRPM(0); // autoRamp will push it upward

    modes[modeIndex].onEnter?.();
  }

  // ----- MODES -----
  let modeIndex = 1;
  const modes = [
    {
      name: "Classic (B/W)",
      onEnter() { setDotStroke(false); classicColors(); },
      update(dt) {}
    },
    {
      name: "Indexed Color (Stepped)",
      onEnter() { setDotStroke(false); updateColors(); },
      update(dt) {
        hue += (speed * 0.02 * dt);
        hue = Math.round(hue / stepSize) * stepSize;
        updateColors();
      }
    },
    {
      name: "Outlined Eyes (Smooth Hue)",
      onEnter() { setDotStroke(true); updateColors(); },
      update(dt) {
        hue += (speed * 0.02 * dt);
        updateColors();
      }
    }
  ];

  function applyMode(i) {
    modeIndex = (i + modes.length) % modes.length;
    modeNameEl.textContent = modes[modeIndex].name;
    modes[modeIndex].onEnter?.();
  }

  function nextMode() { applyMode(modeIndex + 1); }

  // ----- UI EVENTS -----
  slider.addEventListener("input", () => {
    // Manual throttle cancels cruise + auto ramp (like pressing the gas)
    cancelCruise();
    autoRamp = false;
    setTargetRPM(Number(slider.value));
  });

  toggleBtn.addEventListener("click", () => setRunning(!running));
  resetBtn.addEventListener("click", resetAll);
  brakeBtn.addEventListener("click", brake);
  cruiseBtn.addEventListener("click", cruise);
  modeBtn.addEventListener("click", nextMode);

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") {
      e.preventDefault();
      setRunning(!running);
      return;
    }

    if (e.key === "m" || e.key === "M") { nextMode(); return; }
    if (e.key === "r" || e.key === "R") { resetAll(); return; }
    if (e.key === "b" || e.key === "B") { brake(); return; }
    if (e.key === "c" || e.key === "C") { cruise(); return; }

    if (e.key === "ArrowUp") {
      cancelCruise();
      autoRamp = false;
      setTargetRPM(targetRPM + 5);
      return;
    }

    if (e.key === "ArrowDown") {
      cancelCruise();
      autoRamp = false;
      setTargetRPM(targetRPM - 5);
      return;
    }
  });

  // ----- ANIMATION LOOP -----
  function tick(now) {
    const dt = (now - last) / 1000;
    last = now;

    if (running) {
      // Auto ramp targetRPM upward to max over ~10 seconds (0 -> 600)
      if (autoRamp) {
        cancelCruise();
        const rampRate = 600 / 10; // RPM per second
        setTargetRPM(targetRPM + rampRate * dt);
        if (targetRPM >= 600) autoRamp = false;
      }

      const targetSpeed = rpmToDeg(targetRPM);

      // 10-second accel from 0 -> 600 RPM (600 RPM = 3600 deg/sec => 360 deg/sec^2)
      const maxAccel = 360; // deg/sec^2

      const delta = targetSpeed - speed;
      const step = Math.sign(delta) * Math.min(Math.abs(delta), maxAccel * dt);
      speed += step;

      angle = (angle + speed * dt) % 360;
      spinner.style.transform = `rotate(${angle}deg)`;

      rpmEl.textContent = (speed / 6).toFixed(1);

      modes[modeIndex].update?.(dt);
    }

    requestAnimationFrame(tick);
  }

  // init
  applyMode(modeIndex);
  resetAll(); // cold start + auto ramp
  requestAnimationFrame(tick);
</script>

</body>
</html>





