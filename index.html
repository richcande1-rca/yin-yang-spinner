<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Yin Yang — Multi-Mode Spinner (v3.3 Perf + BG Sync Fix + Edge Respawn)</title>

<style>
  html, body {
    margin: 0;
    background: black;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, sans-serif;
    color: #ddd;
  }

  /* ----- BACKGROUND LAYERS ----- */
  #bgAurora, #bgShade {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  /* Explicit layer stack */
  #bgAurora { z-index: 0; }
  #tunnel   { z-index: 1; }
  #bgShade  { z-index: 2; }
  #stars    { z-index: 3; }
  #container{ z-index: 4; position: relative; }

  #bgAurora{
    opacity: 1;
    background:
      radial-gradient(1200px 900px at var(--ax1, 30%) var(--ay1, 35%),
        hsla(var(--ah1, 180), 100%, 55%, var(--aa1, 0.22)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 60%),
      radial-gradient(1000px 800px at var(--ax2, 70%) var(--ay2, 55%),
        hsla(var(--ah2, 260), 100%, 55%, var(--aa2, 0.18)) 0%,
        hsla(var(--ah1, 180), 100%, 50%, 0.00) 62%),
      radial-gradient(900px 700px at var(--ax3, 55%) var(--ay3, 25%),
        hsla(var(--ah3, 40), 100%, 55%, var(--aa3, 0.14)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 65%);
    mix-blend-mode: screen;
    will-change: background, filter;
  }

  /* Tunnel canvas (sized in JS) */
  #tunnel{
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    transform-origin: 50% 50%;
    pointer-events: none;
    mix-blend-mode: screen;
    will-change: transform;
  }

  #bgShade{
    background: radial-gradient(circle at 50% 50%,
      rgba(0,0,0,0.05) 0%,
      rgba(0,0,0,0.55) 65%,
      rgba(0,0,0,0.95) 100%);
  }

  #stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    mix-blend-mode: screen;
    display: block;
    width: 100%;
    height: 100%;
  }

  /* ----- TOP BACKGROUND BUTTONS ----- */
  #bgUI {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    user-select: none;
  }

  .chip {
    background: rgba(10,10,10,0.55);
    border: 1px solid rgba(120,120,120,0.35);
    color: #ddd;
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    touch-action: manipulation;
  }
  .chip:active { transform: translateY(1px); }
  .chip.off {
    opacity: 0.45;
    border-color: rgba(120,120,120,0.20);
  }

  /* ----- SPINNER ----- */
  #container {
    width: 420px;
    height: 420px;
  }

  @media (max-width: 520px) {
    #container { width: 320px; height: 320px; }
    #hud { bottom: -140px; }
    input[type="range"] { width: 210px; }
    #bgUI { top: 8px; left: 8px; gap: 6px; }
    .chip { padding: 6px 9px; font-size: 12px; }
  }

  svg {
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
    transform-box: fill-box;
    will-change: transform, filter;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  #hud {
    position: absolute;
    bottom: -120px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    opacity: 0.88;
    user-select: none;
  }

  .row { margin-top: 6px; }
  input[type="range"] { width: 240px; }

  .small {
    font-size: 12px;
    opacity: 0.72;
    margin-top: 8px;
    line-height: 1.4;
  }

  kbd {
    background: #222;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 1px 5px;
  }

  .controls {
    display: inline-flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: #111;
    color: #ddd;
    border: 1px solid #444;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
    touch-action: manipulation;
  }

  button:active { transform: translateY(1px); }
  .paused { opacity: 0.6; }
</style>
</head>

<body>

<!-- TOP BACKGROUND BUTTONS -->
<div id="bgUI" aria-label="Background toggles">
  <button class="chip" id="btnBG"     type="button" title="Toggle all backgrounds (G)">BG</button>
  <button class="chip" id="btnAurora" type="button" title="Toggle aurora (A)">Aurora</button>
  <button class="chip" id="btnTunnel" type="button" title="Toggle tunnel (T)">Tunnel</button>
  <button class="chip" id="btnStars"  type="button" title="Toggle stars (F)">Stars</button>
  <button class="chip" id="btnStrobe" type="button" title="Toggle strobe beat (S)">Strobe</button>
</div>

<canvas id="stars"></canvas>
<div id="bgAurora"></div>
<canvas id="tunnel"></canvas>
<div id="bgShade"></div>

<div id="container">
  <svg id="spinner" viewBox="-100 -100 200 200" aria-label="Yin Yang spinner" role="img">
    <defs>
      <filter id="warp" x="-30%" y="-30%" width="160%" height="160%">
        <feTurbulence id="turb" type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="2" />
        <feDisplacementMap id="disp" in="SourceGraphic" scale="0" />
      </filter>
    </defs>

    <g id="art">
      <circle id="outer" r="100" fill="white"/>
      <path id="half" d="
        M 0 -100
        A 100 100 0 0 1 0 100
        A 50 50 0 0 0 0 0
        A 50 50 0 0 1 0 -100
      " fill="black"/>
      <circle id="lobe1" cx="0" cy="-50" r="50" fill="white"/>
      <circle id="lobe2" cx="0" cy="50"  r="50" fill="black"/>
      <circle id="dot1" cx="0" cy="-42" r="14" fill="black"/>
      <circle id="dot2" cx="0" cy="42"  r="14" fill="white"/>
    </g>
  </svg>

  <div id="hud">
    <div>
      <strong>RPM:</strong>
      <span id="rpm">0.0</span>
      <span id="state"></span>
    </div>

    <div class="row">
      <input id="rpmSlider" type="range" min="0" max="600" step="1" value="0" />
      <span><strong>Target:</strong> <span id="rpmTarget">0</span></span>
    </div>

    <div class="controls">
      <button id="toggleBtn" type="button">Start</button>
      <button id="modeBtn" type="button">Mode</button>
    </div>

    <div class="small">
      <strong>Mode:</strong> <span id="modeName"></span><br>
      <kbd>Space</kbd> start/stop · <kbd>↑</kbd>/<kbd>↓</kbd> speed · <kbd>M</kbd> mode<br>
      <span style="opacity:.8">
        <kbd>G</kbd> bg all · <kbd>A</kbd> aurora · <kbd>T</kbd> tunnel · <kbd>F</kbd> stars · <kbd>S</kbd> bg strobe
      </span>
      <br>
      <span style="opacity:.8">
        <kbd>X</kbd> clear stars buffer
      </span>
    </div>
  </div>
</div>

<script>
  const spinner = document.getElementById("spinner");
  const art = document.getElementById("art");

  const outer = document.getElementById("outer");
  const half  = document.getElementById("half");
  const lobe1 = document.getElementById("lobe1");
  const lobe2 = document.getElementById("lobe2");
  const dot1  = document.getElementById("dot1");
  const dot2  = document.getElementById("dot2");

  const turb = document.getElementById("turb");
  const disp = document.getElementById("disp");

  const rpmEl = document.getElementById("rpm");
  const stateEl = document.getElementById("state");
  const slider = document.getElementById("rpmSlider");
  const rpmTargetEl = document.getElementById("rpmTarget");

  const toggleBtn = document.getElementById("toggleBtn");
  const modeBtn = document.getElementById("modeBtn");
  const modeNameEl = document.getElementById("modeName");

  const bgAurora = document.getElementById("bgAurora");

  const stars = document.getElementById("stars");
  const ctx = stars.getContext("2d", { alpha: true });

  const tunnel = document.getElementById("tunnel");
  const tctx = tunnel.getContext("2d", { alpha: true });

  // BG UI buttons
  const btnBG     = document.getElementById("btnBG");
  const btnAurora = document.getElementById("btnAurora");
  const btnTunnel = document.getElementById("btnTunnel");
  const btnStars  = document.getElementById("btnStars");
  const btnStrobe = document.getElementById("btnStrobe");

  // ----- STATE -----
  let angle = 0;
  let speed = 0;            // deg/sec
  let running = false;      // no auto-start

  let targetRPM = 0;
  let autoRamp = false;     // Start ramps to max

  let last = performance.now();
  let hue = 0;
  let t = 0;

  const steps = 24;
  const stepSize = 360 / steps;

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
  function rpmToDeg(rpm) { return rpm * 6; }
  const MAX_RPM = 600;

  // Intensity
  const INT = 0.75;

  // ---- SAFETY HELPERS ----
  const TAU = Math.PI * 2;
  function safeNum(x, fallback = 0) { return Number.isFinite(x) ? x : fallback; }
  function normHue(h) {
    if (!Number.isFinite(h)) return 0;
    h %= 360;
    if (h < 0) h += 360;
    return h;
  }

  // ----- UI THROTTLE / CACHES -----
  let uiLastWrite = 0;
  let lastShownRPM = "";
  let lastShownTarget = "";
  let lastSlider = -1;

  function writeTargetUI(rpm) {
    const rounded = Math.round(rpm);
    if (rounded !== lastSlider) {
      slider.value = String(rounded);
      lastSlider = rounded;
    }
    const s = String(rounded);
    if (s !== lastShownTarget) {
      rpmTargetEl.textContent = s;
      lastShownTarget = s;
    }
  }

  function writeRPMUI(rpmFloat) {
    const s = rpmFloat.toFixed(1);
    if (s !== lastShownRPM) {
      rpmEl.textContent = s;
      lastShownRPM = s;
    }
  }

  function updateColors() {
    outer.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
    half.setAttribute("fill",  `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    lobe1.setAttribute("fill", `hsl(${((hue+90)%360+360)%360},100%,60%)`);
    lobe2.setAttribute("fill", `hsl(${((hue+270)%360+360)%360},100%,60%)`);
    dot1.setAttribute("fill",  `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    dot2.setAttribute("fill",  `hsl(${(hue%360+360)%360},100%,60%)`);
  }

  function classicColors() {
    outer.setAttribute("fill", "white");
    half.setAttribute("fill", "black");
    lobe1.setAttribute("fill", "white");
    lobe2.setAttribute("fill", "black");
    dot1.setAttribute("fill", "black");
    dot2.setAttribute("fill", "white");
  }

  function setDotStroke(on) {
    if (on) {
      dot1.setAttribute("stroke", "white");
      dot1.setAttribute("stroke-width", "2");
      dot2.setAttribute("stroke", "black");
      dot2.setAttribute("stroke-width", "2");
    } else {
      dot1.removeAttribute("stroke");
      dot1.removeAttribute("stroke-width");
      dot2.removeAttribute("stroke");
      dot2.removeAttribute("stroke-width");
    }
  }

  function setRunning(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? "Stop" : "Start";
    stateEl.textContent = running ? "" : " (stopped)";
    rpmEl.classList.toggle("paused", !running);

    if (running) autoRamp = true;
    else autoRamp = false;
  }

  function setTargetRPM(rpm) { targetRPM = clamp(rpm, 0, MAX_RPM); }

  function clearTrippyFX() {
    art.removeAttribute("filter");
    spinner.style.filter = "";
    spinner.style.mixBlendMode = "";
    spinner.style.transformOrigin = "50% 50%";
  }

  // ----- SPINNER MODES -----
  let modeIndex = 1;
  const modes = [
    { name: "Classic (B/W)", onEnter(){ clearTrippyFX(); setDotStroke(false); classicColors(); }, update(dt){} },
    {
      name: "Indexed Color (Stepped)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        hue = Math.round(hue / stepSize) * stepSize;
        updateColors();
      }
    },
    {
      name: "Outlined Eyes (Smooth Hue)",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); },
      update(dt){ hue += (speed * 0.02 * dt); updateColors(); }
    },
    {
      name: "Neon Glow Pulse",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); spinner.style.mixBlendMode = "screen"; },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const pulse = 0.5 + 0.5 * Math.sin(t * 2.2);
        const glow = clamp((rpm / 600) * 18 + pulse * 8, 0, 28);
        spinner.style.filter = `drop-shadow(0 0 ${glow.toFixed(1)}px hsl(${(hue%360+360)%360},100%,60%))`;
      }
    },
    {
      name: "Warp Field (Liquid)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); art.setAttribute("filter","url(#warp)"); },
      update(dt){
        hue += (speed * 0.018 * dt);
        updateColors();
        const rpm = speed / 6;
        const energy = rpm / 600;
        const wobble = 0.5 + 0.5 * Math.sin(t * 1.7);
        const bf = 0.010 + 0.012 * (0.35 + wobble) * energy;
        turb.setAttribute("baseFrequency", bf.toFixed(4));
        const scale = 2 + 28 * energy * (0.35 + wobble);
        disp.setAttribute("scale", scale.toFixed(1));
      }
    },
    {
      name: "Strobe Invert (Beat)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const beatHz = 2 + 10 * (rpm / 600);
        const strobe = (Math.sin(t * Math.PI * 2 * beatHz) > 0.4);
        const wob = 1 + 0.012 * Math.sin(t * 3.3);
        spinner.style.filter = strobe ? "invert(1) contrast(1.15)" : "contrast(1.05)";
        spinner.style.transform = `rotate(${angle}deg) scale(${wob.toFixed(4)})`;
      }
    }
  ];

  function applyMode(i) {
    modeIndex = (i + modes.length) % modes.length;
    modeNameEl.textContent = modes[modeIndex].name;
    modes[modeIndex].onEnter?.();
  }
  function nextMode(){ applyMode(modeIndex + 1); }

  // ----- BACKGROUND SYSTEM -----
  let bgOn = true;
  let bgAuroraOn = true;
  let bgTunnelOn = true;
  let bgStarsOn = true;
  let bgStrobe = true;

  function syncBgButtons() {
    btnBG.classList.toggle("off", !bgOn);

    const effA = bgOn && bgAuroraOn;
    const effT = bgOn && bgTunnelOn;
    const effS = bgOn && bgStarsOn;
    const effB = bgOn && bgStrobe;

    btnAurora.classList.toggle("off", !effA);
    btnTunnel.classList.toggle("off", !effT);
    btnStars.classList.toggle("off",  !effS);
    btnStrobe.classList.toggle("off", !effB);
  }

  function clearStarsCanvas() {
    trailDebt = 0;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.clearRect(0, 0, W, H);
  }

  function clearTunnelCanvas() {
    tctx.clearRect(0, 0, TW, TH);
  }

  function setBgFlag(name, value) {
    // normalize
    const v = !!value;

    if (name === "bgOn")       bgOn = v;
    if (name === "aurora")     bgAuroraOn = v;
    if (name === "tunnel")     bgTunnelOn = v;
    if (name === "stars")      bgStarsOn = v;
    if (name === "strobe")     bgStrobe = v;

    // when stars are re-enabled, guarantee good state
    if (name === "stars" && bgStarsOn) {
      if (!W || !H || starsList.length === 0) resizeStars();
      clearStarsCanvas();
    }

    syncBgButtons();
  }

  btnBG.addEventListener("click",     () => setBgFlag("bgOn",   !bgOn));
  btnAurora.addEventListener("click", () => setBgFlag("aurora", !bgAuroraOn));
  btnTunnel.addEventListener("click", () => setBgFlag("tunnel", !bgTunnelOn));

  btnStars.addEventListener("click", () => setBgFlag("stars", !bgStarsOn));
  btnStrobe.addEventListener("click", () => setBgFlag("strobe", !bgStrobe));

  let bgLastWrite = 0;
  let bgPhase = 0;

  // Starfield
  let W = 0, H = 0, DPR = 1;
  let starsList = [];

  // Trail cleanup
  let trailDebt = 0;

  // Edge-in respawn (more continuous vibe)
  function respawnStar(s) {
    if (!W || !H) return;

    const pad = 60;
    const side = (Math.random() * 4) | 0;

    if (side === 0) { s.x = -pad;      s.y = Math.random() * H; }
    if (side === 1) { s.x = W + pad;   s.y = Math.random() * H; }
    if (side === 2) { s.x = Math.random() * W; s.y = -pad; }
    if (side === 3) { s.x = Math.random() * W; s.y = H + pad; }

    s.z  = Math.random();
    s.r  = 0.25 + Math.random() * 0.60;
    s.tw = Math.random() * TAU;
  }

  function resizeStars() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    stars.width = Math.floor(W * DPR);
    stars.height = Math.floor(H * DPR);
    stars.style.width = W + "px";
    stars.style.height = H + "px";

    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    const base = Math.floor((W * H) / 9000);
    const count = clamp(Math.floor(base * 1.9), 220, 620);

    starsList = [];
    for (let i = 0; i < count; i++) {
      const s = { x: 0, y: 0, z: 0, r: 0, tw: 0 };
      respawnStar(s);
      starsList.push(s);
    }

    trailDebt = 0;
  }

  // ----- TUNNEL CANVAS -----
  let TW = 0, TH = 0, TDPR = 1;
  let ringSpacing = 16;
  let ringCount = 0;
  let maxR = 0;

  let ringPhase = 0;
  let activeRing = 0;

  const baseTunnel = document.createElement("canvas");
  const bctx = baseTunnel.getContext("2d", { alpha: true });
  let baseDirty = true;

  let lastActiveRing = -1;
  let tunnelLastDraw = 0;

  function resizeTunnel() {
    TDPR = 1;

    const vmax = Math.max(window.innerWidth || 1, window.innerHeight || 1);
    const side = Math.max(1, Math.floor(vmax * 1.8));

    TW = side;
    TH = side;

    tunnel.style.width = side + "px";
    tunnel.style.height = side + "px";

    tunnel.width  = Math.floor(TW * TDPR);
    tunnel.height = Math.floor(TH * TDPR);

    tctx.setTransform(TDPR, 0, 0, TDPR, 0, 0);

    const cx = TW * 0.5;
    const cy = TH * 0.5;
    maxR = Math.hypot(cx, cy);

    ringCount = Math.max(18, Math.floor(maxR / ringSpacing));

    baseTunnel.width  = tunnel.width;
    baseTunnel.height = tunnel.height;
    bctx.setTransform(TDPR, 0, 0, TDPR, 0, 0);
    baseDirty = true;

    lastActiveRing = -1;
  }

  function rebuildBaseTunnel() {
    if (!Number.isFinite(TW) || !Number.isFinite(TH) || TW <= 0 || TH <= 0) return;
    if (!Number.isFinite(ringCount) || ringCount <= 0) return;

    baseDirty = false;
    bctx.clearRect(0, 0, TW, TH);

    const cx = TW * 0.5;
    const cy = TH * 0.5;

    const baseAlpha = 0.11;
    const baseWidth = 2.2;

    bctx.lineCap = "round";

    for (let i = 0; i < ringCount; i++) {
      const r = maxR - i * ringSpacing;
      if (r <= 0) break;

      const alt = (i % 2 === 0) ? 1.0 : 0.70;
      bctx.strokeStyle = `rgba(140,210,255, ${(baseAlpha * alt).toFixed(3)})`;
      bctx.lineWidth = baseWidth;

      bctx.beginPath();
      bctx.arc(cx, cy, r, 0, Math.PI * 2);
      bctx.stroke();
    }
  }

  function drawTunnel(energy, pop) {
    if (baseDirty) rebuildBaseTunnel();

    tctx.clearRect(0, 0, TW, TH);

    const baseGain = 0.78 + 0.55 * energy;
    tctx.globalAlpha = clamp(baseGain, 0.65, 1.0);
    tctx.drawImage(baseTunnel, 0, 0);
    tctx.globalAlpha = 1;

    const cx = TW * 0.5;
    const cy = TH * 0.5;

    const hiAlpha = 0.62 + 0.20 * energy + 0.55 * pop;
    const hiWidth = 4.4 + 2.8 * energy;

    const tailAlpha = 0.22 + 0.18 * energy + 0.20 * pop;
    const tailWidth = 3.2 + 1.6 * energy;

    tctx.lineCap = "round";

    const rHead = maxR - activeRing * ringSpacing;
    if (rHead > 0) {
      tctx.strokeStyle = `rgba(255,255,255, ${Math.min(1, hiAlpha).toFixed(3)})`;
      tctx.lineWidth = hiWidth;
      tctx.beginPath();
      tctx.arc(cx, cy, rHead, 0, Math.PI * 2);
      tctx.stroke();

      const idx1 = (activeRing + 1) % ringCount;
      const rTail1 = maxR - idx1 * ringSpacing;
      tctx.strokeStyle = `rgba(190,230,255, ${Math.min(1, tailAlpha).toFixed(3)})`;
      tctx.lineWidth = tailWidth;
      tctx.beginPath();
      tctx.arc(cx, cy, rTail1, 0, Math.PI * 2);
      tctx.stroke();

      const idx2 = (activeRing + 2) % ringCount;
      const rTail2 = maxR - idx2 * ringSpacing;
      tctx.strokeStyle = `rgba(160,210,255, ${Math.min(1, tailAlpha * 0.55).toFixed(3)})`;
      tctx.lineWidth = tailWidth * 0.9;
      tctx.beginPath();
      tctx.arc(cx, cy, rTail2, 0, Math.PI * 2);
      tctx.stroke();
    }
  }

  // ----- HYPERSPACE STAR HELPERS -----
  function drawStarDot(x, y, size, alpha, hh) {
    ctx.save();

    ctx.fillStyle = `hsla(${hh},100%,78%,1)`;

    ctx.globalAlpha = Math.min(1, alpha * 0.40);
    ctx.beginPath();
    ctx.arc(x, y, size * 1.9, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = Math.min(1, alpha);
    ctx.beginPath();
    ctx.arc(x, y, Math.max(0.5, size * 0.70), 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawStarStreak(x, y, vx, vy, len, width, alpha, hh) {
    ctx.save();

    const mag = Math.hypot(vx, vy) || 1;
    const ux = vx / mag;
    const uy = vy / mag;

    const x2 = x - ux * len;
    const y2 = y - uy * len;

    ctx.strokeStyle = `hsla(${hh},100%,78%,1)`;
    ctx.lineWidth = width;
    ctx.globalAlpha = Math.min(1, alpha);

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    ctx.restore();
  }

  // BG off: clear ONCE, then skip work until re-enabled
  let bgWasOn = true;

  function updateBackground(dt, now) {
    tunnel.style.display = (bgOn && bgTunnelOn) ? "block" : "none";

    if (!bgOn) {
      if (bgWasOn) {
        bgAurora.style.opacity = "0";
        clearTunnelCanvas();
        clearStarsCanvas();
        bgWasOn = false;
      }
      return;
    }
    bgWasOn = true;

    const rpm = speed / 6;
    const energy = clamp(rpm / 600, 0, 1);
    const e = energy * INT;

    let pop = 0;
    if (bgStrobe) {
      const beatHz = 1.2 + 10.5 * e;
      const st = Math.sin(t * Math.PI * 2 * beatHz);
      pop = Math.max(0, (st - 0.65) / 0.35);
      pop = pop * pop;
    }

    // ---- Tunnel stepping ----
    if (bgTunnelOn && Number.isFinite(ringCount) && ringCount > 0 && Number.isFinite(maxR) && maxR > 0) {
      const stepsPerSec = (rpm / 60) * ringCount;
      ringPhase = (ringPhase - stepsPerSec * dt) % ringCount;
      if (ringPhase < 0) ringPhase += ringCount;
      activeRing = Math.floor(ringPhase);

      const swell = 1 + 0.05 * (energy * INT);
      tunnel.style.transform = `translate(-50%, -50%) scale(${swell.toFixed(4)})`;

      const ringChanged = (activeRing !== lastActiveRing);
      const popHot = (pop > 0.22);
      const timeKick = (now - tunnelLastDraw > 90);

      if (ringChanged || popHot || timeKick) {
        drawTunnel(energy * INT, pop);
        lastActiveRing = activeRing;
        tunnelLastDraw = now;
      }
    } else {
      tunnel.style.transform = `translate(-50%, -50%)`;
    }

    // Aurora throttled updates
    if (now - bgLastWrite > 50) {
      bgLastWrite = now;

      const rate = 0.10 + 1.15 * e;
      bgPhase += dt * rate;
      const tri = 1 - Math.abs(((bgPhase % 1) * 2) - 1);

      if (bgAuroraOn) {
        const base = (hue + 30 + t * 8) % 360;
        const ah1 = base + 220 * tri;
        const ah2 = base + 180 - 220 * tri;
        const ah3 = base + 90 + 120 * (1 - tri);

        const aa1 = (0.10 + 0.28 * e) + pop * 0.14;
        const aa2 = (0.08 + 0.22 * e) + pop * 0.12;
        const aa3 = (0.06 + 0.18 * e) + pop * 0.10;

        const ax1 = 25 + 18 * Math.sin(t * (0.22 + 0.5 * e));
        const ay1 = 35 + 10 * Math.cos(t * (0.18 + 0.4 * e));
        const ax2 = 70 + 15 * Math.cos(t * (0.17 + 0.55 * e));
        const ay2 = 55 + 12 * Math.sin(t * (0.20 + 0.35 * e));
        const ax3 = 55 + 22 * Math.sin(t * (0.14 + 0.45 * e));
        const ay3 = 25 + 16 * Math.cos(t * (0.16 + 0.42 * e));

        bgAurora.style.opacity = "1";
        bgAurora.style.setProperty("--ah1", ah1.toFixed(1));
        bgAurora.style.setProperty("--ah2", ah2.toFixed(1));
        bgAurora.style.setProperty("--ah3", ah3.toFixed(1));
        bgAurora.style.setProperty("--aa1", aa1.toFixed(3));
        bgAurora.style.setProperty("--aa2", aa2.toFixed(3));
        bgAurora.style.setProperty("--aa3", aa3.toFixed(3));
        bgAurora.style.setProperty("--ax1", ax1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay1", ay1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax2", ax2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay2", ay2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax3", ax3.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay3", ay3.toFixed(1) + "%");

        const bright = 1 + 0.85 * pop;
        bgAurora.style.filter = `saturate(1.2) contrast(1.05) brightness(${bright.toFixed(2)})`;
      } else {
        bgAurora.style.opacity = "0";
      }
    }

    // ----- STARS -----
    if (bgStarsOn) {
      const cx = W * 0.5;
      const cy = H * 0.5;

      speed = safeNum(speed, 0);
      hue   = safeNum(hue, 0);

      const energyS = clamp((speed / 6) / 600, 0, 1);
      const hyper = clamp((energyS - 0.28) / 0.72, 0, 1);
      const hyper2 = hyper * hyper;

      const crispMode = (hyper < 0.06);

      // HARD RESET canvas state every frame
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";

      if (crispMode) {
        trailDebt = 0;
        ctx.clearRect(0, 0, W, H);
      } else {
        const fade = (0.04 + 0.10 * hyper2);
        trailDebt += fade;

        if (trailDebt > 1.25) {
          ctx.clearRect(0, 0, W, H);
          trailDebt = 0;
        } else {
          ctx.fillStyle = `rgba(0,0,0,${fade})`;
          ctx.fillRect(0, 0, W, H);
        }
      }

      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 1;

      const breathe = 0.6 + 0.4 * Math.sin(t * 1.2);
      const accel = (0.9 + 6.5 * (energyS * energyS) + 8.0 * (energyS * energyS * energyS)) * INT;
      const warp = accel * breathe;

      const pad = 60;

      for (const s of starsList) {
        if (!Number.isFinite(s.x) || !Number.isFinite(s.y) || !Number.isFinite(s.z) || !Number.isFinite(s.r) || !Number.isFinite(s.tw)) {
          respawnStar(s);
        }

        s.tw += dt * (0.9 + 2.4 * energyS) * (0.6 + s.z);
        const twinkle = 0.55 + 0.45 * Math.sin(s.tw);

        const dx = s.x - cx;
        const dy = s.y - cy;

        const swirl = 0.0040 * warp;
        const cs = Math.cos(swirl), sn = Math.sin(swirl);
        const rx = dx * cs - dy * sn;
        const ry = dx * sn + dy * cs;

        const denom = (160 + 520 * s.z);
        const push = (warp * 220) * dt;

        const vx = (rx / denom) * push;
        const vy = (ry / denom) * push;

        if (!Number.isFinite(vx) || !Number.isFinite(vy)) {
          respawnStar(s);
          continue;
        }

        s.x += vx;
        s.y += vy;

        if (s.x < -pad || s.x > W + pad || s.y < -pad || s.y > H + pad) {
          respawnStar(s);
          continue;
        }

        const size  = s.r * (0.95 + 0.70 * (energyS * INT)) * (0.85 + 0.65 * twinkle);
        const alpha = (0.45 + 0.45 * (energyS * INT)) * (0.70 + 0.75 * twinkle);

        const hhn = normHue(hue + 110 * (s.z - 0.5));

        if (!crispMode) {
          const speedPx = Math.hypot(vx, vy);
          const len = (10 + 150 * hyper2) * (0.35 + 0.95 * s.z) * (0.4 + 2.6 * speedPx);
          const w   = (0.8 + 2.8 * hyper) * (0.35 + 0.85 * s.z);

          drawStarStreak(s.x, s.y, vx, vy, len, w, Math.min(1, alpha * (0.55 + 0.95 * hyper)), hhn);
        }

        drawStarDot(s.x, s.y, size, alpha, hhn);
      }

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
    } else {
      clearStarsCanvas();
    }
  }

  // ----- UI EVENTS -----
  slider.addEventListener("input", () => {
    autoRamp = false;
    setTargetRPM(Number(slider.value));
    writeTargetUI(targetRPM);
  });

  toggleBtn.addEventListener("click", () => setRunning(!running));
  modeBtn.addEventListener("click", nextMode);

  document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive: false });

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") { e.preventDefault(); setRunning(!running); return; }
    if (e.key === "m" || e.key === "M") { nextMode(); return; }

    if (e.key === "g" || e.key === "G") { setBgFlag("bgOn", !bgOn); return; }
    if (e.key === "a" || e.key === "A") { setBgFlag("aurora", !bgAuroraOn); return; }
    if (e.key === "t" || e.key === "T") { setBgFlag("tunnel", !bgTunnelOn); return; }
    if (e.key === "f" || e.key === "F") { setBgFlag("stars", !bgStarsOn); return; }
    if (e.key === "s" || e.key === "S") { setBgFlag("strobe", !bgStrobe); return; }

    if (e.key === "x" || e.key === "X") { clearStarsCanvas(); return; }

    if (e.key === "ArrowUp")   { autoRamp = false; setTargetRPM(targetRPM + 5); writeTargetUI(targetRPM); return; }
    if (e.key === "ArrowDown") { autoRamp = false; setTargetRPM(targetRPM - 5); writeTargetUI(targetRPM); return; }
  });

  // ----- RESIZE HOOKS -----
  window.addEventListener("resize", () => {
    resizeTunnel();
    rebuildBaseTunnel();
    resizeStars();
  });

  // ----- ANIMATION LOOP -----
  function tick(now) {
    let dt = (now - last) / 1000;
    last = now;

    dt = Math.min(dt, 0.05);
    t += dt;

    if (running) {
      if (autoRamp) {
        const rampSeconds = 10;
        const rampRate = MAX_RPM / rampSeconds;
        setTargetRPM(targetRPM + rampRate * dt);
        if (targetRPM >= MAX_RPM) autoRamp = false;
      }

      const targetSpeed = rpmToDeg(targetRPM);

      const accel = 360;
      const decel = 900;
      const maxAccel = (targetSpeed < speed) ? decel : accel;

      const delta = targetSpeed - speed;
      const step = Math.sign(delta) * Math.min(Math.abs(delta), maxAccel * dt);
      speed += step;

      angle = (angle + speed * dt) % 360;

      if (modes[modeIndex].name !== "Strobe Invert (Beat)") {
        spinner.style.transform = `rotate(${angle}deg)`;
      }

      writeRPMUI(speed / 6);
      modes[modeIndex].update?.(dt);
    } else {
      writeRPMUI(speed / 6);
    }

    updateBackground(dt, now);

    if (now - uiLastWrite > 50) {
      uiLastWrite = now;
      writeTargetUI(targetRPM);
    }

    requestAnimationFrame(tick);
  }

  // init
  applyMode(modeIndex);
  resizeTunnel();
  rebuildBaseTunnel();
  resizeStars();

  setTargetRPM(0);
  writeTargetUI(0);
  writeRPMUI(0);
  setRunning(false);
  syncBgButtons();

  requestAnimationFrame(tick);
</script>

</body>
</html>
