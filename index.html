<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Yin Yang — Multi-Mode Spinner (Factory Loaded v3 - Disney Tunnel)</title>

<style>
  html, body {
    margin: 0;
    background: black;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, sans-serif;
    color: #ddd;
  }

  /* ----- BACKGROUND LAYERS ----- */
  #bgAurora, #bgShade {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  /* Explicit layer stack */
  #bgAurora { z-index: 0; }
  #tunnel   { z-index: 1; }
  #bgShade  { z-index: 2; }      /* dark vignette */
  #stars    { z-index: 3; }      /* stars ABOVE vignette */
  #container{ z-index: 4; position: relative; }

  #bgAurora{
    opacity: 1;
    background:
      radial-gradient(1200px 900px at var(--ax1, 30%) var(--ay1, 35%),
        hsla(var(--ah1, 180), 100%, 55%, var(--aa1, 0.22)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 60%),
      radial-gradient(1000px 800px at var(--ax2, 70%) var(--ay2, 55%),
        hsla(var(--ah2, 260), 100%, 55%, var(--aa2, 0.18)) 0%,
        hsla(var(--ah1, 180), 100%, 50%, 0.00) 62%),
      radial-gradient(900px 700px at var(--ax3, 55%) var(--ay3, 25%),
        hsla(var(--ah3, 40), 100%, 55%, var(--aa3, 0.14)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 65%);
    mix-blend-mode: screen;
    will-change: background, filter;
  }

  /* CRISP tunnel on canvas */
  #tunnel{
    position: fixed;
    left: 50%;
    top: 50%;
    width: 180vmax;
    height: 180vmax;
    transform: translate(-50%, -50%);
    transform-origin: 50% 50%;
    pointer-events: none;
    mix-blend-mode: screen;
    will-change: transform;
  }

  #bgShade{
    background: radial-gradient(circle at 50% 50%,
      rgba(0,0,0,0.05) 0%,
      rgba(0,0,0,0.55) 65%,
      rgba(0,0,0,0.95) 100%);
  }

  #stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    mix-blend-mode: screen;
  }

  /* ----- SPINNER ----- */
  #container {
    width: 420px;
    height: 420px;
  }

  @media (max-width: 520px) {
    #container { width: 320px; height: 320px; }
    #hud { bottom: -140px; }
    input[type="range"] { width: 210px; }
  }

  svg {
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
    transform-box: fill-box;
    will-change: transform, filter;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  #hud {
    position: absolute;
    bottom: -120px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    opacity: 0.88;
    user-select: none;
  }

  .row { margin-top: 6px; }
  input[type="range"] { width: 240px; }

  .small {
    font-size: 12px;
    opacity: 0.72;
    margin-top: 8px;
    line-height: 1.4;
  }

  kbd {
    background: #222;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 1px 5px;
  }

  .controls {
    display: inline-flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: #111;
    color: #ddd;
    border: 1px solid #444;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
  }

  button:active { transform: translateY(1px); }
  .paused { opacity: 0.6; }

  .cruiseOn {
    border-color: #888;
    box-shadow: 0 0 0 1px #666 inset;
  }
</style>
</head>

<body>

<canvas id="stars"></canvas>
<div id="bgAurora"></div>
<canvas id="tunnel"></canvas>
<div id="bgShade"></div>

<div id="container">
  <svg id="spinner" viewBox="-100 -100 200 200" aria-label="Yin Yang spinner" role="img">
    <defs>
      <filter id="warp" x="-30%" y="-30%" width="160%" height="160%">
        <feTurbulence id="turb" type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="2" />
        <feDisplacementMap id="disp" in="SourceGraphic" scale="0" />
      </filter>
    </defs>

    <g id="art">
      <circle id="outer" r="100" fill="white"/>

      <path id="half" d="
        M 0 -100
        A 100 100 0 0 1 0 100
        A 50 50 0 0 0 0 0
        A 50 50 0 0 1 0 -100
      " fill="black"/>

      <circle id="lobe1" cx="0" cy="-50" r="50" fill="white"/>
      <circle id="lobe2" cx="0" cy="50"  r="50" fill="black"/>

      <circle id="dot1" cx="0" cy="-42" r="14" fill="black"/>
      <circle id="dot2" cx="0" cy="42"  r="14" fill="white"/>
    </g>
  </svg>

  <div id="hud">
    <div>
      <strong>RPM:</strong>
      <span id="rpm">0.0</span>
      <span id="state"></span>
    </div>

    <div class="row">
      <input id="rpmSlider" type="range" min="0" max="600" step="1" value="0" />
      <span><strong>Target:</strong> <span id="rpmTarget">0</span></span>
    </div>

    <div class="controls">
      <button id="toggleBtn" type="button">Pause</button>
      <button id="resetBtn" type="button">Reset</button>
      <button id="brakeBtn" type="button">Brake</button>
      <button id="cruiseBtn" type="button">Cruise</button>
      <button id="modeBtn" type="button">Mode</button>
    </div>

    <div class="small">
      <strong>Mode:</strong> <span id="modeName"></span><br>
      <kbd>Space</kbd> start/stop · <kbd>↑</kbd>/<kbd>↓</kbd> speed · <kbd>R</kbd> reset ·
      <kbd>M</kbd> mode · <kbd>B</kbd> brake · <kbd>C</kbd> cruise<br>
      <span style="opacity:.8">
        <kbd>G</kbd> bg all · <kbd>A</kbd> aurora · <kbd>T</kbd> tunnel · <kbd>F</kbd> stars · <kbd>S</kbd> bg strobe
      </span>
    </div>
  </div>
</div>

<script>
  const spinner = document.getElementById("spinner");
  const art = document.getElementById("art");

  const outer = document.getElementById("outer");
  const half  = document.getElementById("half");
  const lobe1 = document.getElementById("lobe1");
  const lobe2 = document.getElementById("lobe2");
  const dot1  = document.getElementById("dot1");
  const dot2  = document.getElementById("dot2");

  const turb = document.getElementById("turb");
  const disp = document.getElementById("disp");

  const rpmEl = document.getElementById("rpm");
  const stateEl = document.getElementById("state");
  const slider = document.getElementById("rpmSlider");
  const rpmTargetEl = document.getElementById("rpmTarget");

  const toggleBtn = document.getElementById("toggleBtn");
  const resetBtn = document.getElementById("resetBtn");
  const brakeBtn = document.getElementById("brakeBtn");
  const cruiseBtn = document.getElementById("cruiseBtn");
  const modeBtn = document.getElementById("modeBtn");
  const modeNameEl = document.getElementById("modeName");

  const bgAurora = document.getElementById("bgAurora");

  const stars = document.getElementById("stars");
  const ctx = stars.getContext("2d", { alpha: true });

  const tunnel = document.getElementById("tunnel");
  const tctx = tunnel.getContext("2d", { alpha: true });

  // ----- STATE -----
  let angle = 0;
  let speed = 0;           // deg/sec
  let running = true;

  let targetRPM = 0;
  let autoRamp = true;
  let cruiseOn = false;

  let last = performance.now();
  let hue = 0;
  let t = 0;

  const steps = 24;
  const stepSize = 360 / steps;

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
  function rpmToDeg(rpm) { return rpm * 6; }
  const MAX_RPM = 600;

  // Intensity
  const INT = 0.75;

  // ----- UI THROTTLE / CACHES -----
  let uiLastWrite = 0;
  let lastShownRPM = "";
  let lastShownTarget = "";
  let lastSlider = -1;

  function writeTargetUI(rpm) {
    const rounded = Math.round(rpm);
    if (rounded !== lastSlider) {
      slider.value = String(rounded);
      lastSlider = rounded;
    }
    const s = String(rounded);
    if (s !== lastShownTarget) {
      rpmTargetEl.textContent = s;
      lastShownTarget = s;
    }
  }

  function writeRPMUI(rpmFloat) {
    const s = rpmFloat.toFixed(1);
    if (s !== lastShownRPM) {
      rpmEl.textContent = s;
      lastShownRPM = s;
    }
  }

  function updateColors() {
    outer.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
    half.setAttribute("fill", `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    lobe1.setAttribute("fill", `hsl(${((hue+90)%360+360)%360},100%,60%)`);
    lobe2.setAttribute("fill", `hsl(${((hue+270)%360+360)%360},100%,60%)`);
    dot1.setAttribute("fill", `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    dot2.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
  }

  function classicColors() {
    outer.setAttribute("fill", "white");
    half.setAttribute("fill", "black");
    lobe1.setAttribute("fill", "white");
    lobe2.setAttribute("fill", "black");
    dot1.setAttribute("fill", "black");
    dot2.setAttribute("fill", "white");
  }

  function setDotStroke(on) {
    if (on) {
      dot1.setAttribute("stroke", "white");
      dot1.setAttribute("stroke-width", "2");
      dot2.setAttribute("stroke", "black");
      dot2.setAttribute("stroke-width", "2");
    } else {
      dot1.removeAttribute("stroke");
      dot1.removeAttribute("stroke-width");
      dot2.removeAttribute("stroke");
      dot2.removeAttribute("stroke-width");
    }
  }

  function setRunning(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? "Pause" : "Start";
    stateEl.textContent = running ? "" : " (paused)";
    rpmEl.classList.toggle("paused", !running);
  }

  function setTargetRPM(rpm) {
    targetRPM = clamp(rpm, 0, MAX_RPM);
  }

  function setCruiseUI(on) {
    cruiseOn = on;
    cruiseBtn.classList.toggle("cruiseOn", on);
    cruiseBtn.textContent = on ? "Cruise: On" : "Cruise";
  }

  function cancelCruise() { if (cruiseOn) setCruiseUI(false); }

  function brake() {
    autoRamp = false;
    cancelCruise();
    setRunning(true);
    setTargetRPM(0);
  }

  function cruise() {
    if (!cruiseOn) {
      autoRamp = false;
      const currentRPM = speed / 6;
      setTargetRPM(Math.round(currentRPM));
      setCruiseUI(true);
    } else {
      setCruiseUI(false);
      autoRamp = true;
    }
  }

  function clearTrippyFX() {
    art.removeAttribute("filter");
    spinner.style.filter = "";
    spinner.style.mixBlendMode = "";
    spinner.style.transformOrigin = "50% 50%";
  }

  // ----- SPINNER MODES -----
  let modeIndex = 1;
  const modes = [
    { name: "Classic (B/W)", onEnter(){ clearTrippyFX(); setDotStroke(false); classicColors(); }, update(dt){} },
    {
      name: "Indexed Color (Stepped)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        hue = Math.round(hue / stepSize) * stepSize;
        updateColors();
      }
    },
    {
      name: "Outlined Eyes (Smooth Hue)",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); },
      update(dt){ hue += (speed * 0.02 * dt); updateColors(); }
    },
    {
      name: "Neon Glow Pulse",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); spinner.style.mixBlendMode = "screen"; },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const pulse = 0.5 + 0.5 * Math.sin(t * 2.2);
        const glow = clamp((rpm / 600) * 18 + pulse * 8, 0, 28);
        spinner.style.filter = `drop-shadow(0 0 ${glow.toFixed(1)}px hsl(${(hue%360+360)%360},100%,60%))`;
      }
    },
    {
      name: "Warp Field (Liquid)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); art.setAttribute("filter","url(#warp)"); },
      update(dt){
        hue += (speed * 0.018 * dt);
        updateColors();
        const rpm = speed / 6;
        const energy = rpm / 600;
        const wobble = 0.5 + 0.5 * Math.sin(t * 1.7);
        const bf = 0.010 + 0.012 * (0.35 + wobble) * energy;
        turb.setAttribute("baseFrequency", bf.toFixed(4));
        const scale = 2 + 28 * energy * (0.35 + wobble);
        disp.setAttribute("scale", scale.toFixed(1));
      }
    },
    {
      name: "Strobe Invert (Beat)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const beatHz = 2 + 10 * (rpm / 600);
        const strobe = (Math.sin(t * Math.PI * 2 * beatHz) > 0.4);
        const wob = 1 + 0.012 * Math.sin(t * 3.3);
        spinner.style.filter = strobe ? "invert(1) contrast(1.15)" : "contrast(1.05)";
        spinner.style.transform = `rotate(${angle}deg) scale(${wob.toFixed(4)})`;
      }
    }
  ];

  function applyMode(i) {
    modeIndex = (i + modes.length) % modes.length;
    modeNameEl.textContent = modes[modeIndex].name;
    modes[modeIndex].onEnter?.();
  }
  function nextMode(){ applyMode(modeIndex + 1); }

  // ----- BACKGROUND SYSTEM -----
  let bgOn = true;
  let bgAuroraOn = true;
  let bgTunnelOn = true;
  let bgStarsOn = true;
  let bgStrobe = true;

  let bgLastWrite = 0;
  let bgPhase = 0;

  // Starfield
  let W = 0, H = 0, DPR = 1;
  let starsList = [];

  function resizeStars() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    stars.width = Math.floor(W * DPR);
    stars.height = Math.floor(H * DPR);
    stars.style.width = W + "px";
    stars.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    const base = Math.floor((W * H) / 9000);
    const count = clamp(Math.floor(base * 1.9), 220, 620);

    starsList = [];
    for (let i = 0; i < count; i++) {
      starsList.push({
        x: Math.random() * W,
        y: Math.random() * H,
        z: Math.random(),
        r: 0.25 + Math.random() * 0.60,
        tw: Math.random() * Math.PI * 2
      });
    }
  }

  // ----- TUNNEL CANVAS (CRISP) -----
  let TW = 0, TH = 0, TDPR = 1;
  let ringSpacing = 14;    // px between rings (lower = denser)
  let ringCount = 0;
  let maxR = 0;

  let ringPhase = 0;       // advances with rpm, locks timing
  let activeRing = 0;

  function resizeTunnel() {
    TDPR = Math.min(2, window.devicePixelRatio || 1);

    // Use computed CSS size
    const rect = tunnel.getBoundingClientRect();
    TW = Math.max(1, Math.floor(rect.width));
    TH = Math.max(1, Math.floor(rect.height));

    tunnel.width  = Math.floor(TW * TDPR);
    tunnel.height = Math.floor(TH * TDPR);
    tunnel.style.width = rect.width + "px";
    tunnel.style.height = rect.height + "px";

    tctx.setTransform(TDPR, 0, 0, TDPR, 0, 0);

    const cx = TW * 0.5;
    const cy = TH * 0.5;
    maxR = Math.hypot(cx, cy);

    ringCount = Math.max(18, Math.floor(maxR / ringSpacing));
  }

  window.addEventListener("resize", () => {
    resizeTunnel();
    resizeStars();
  });

  function drawTunnel(rpm, energy, pop) {
    // show/hide is handled outside, but draw can be called safely
    tctx.clearRect(0, 0, TW, TH);

    const cx = TW * 0.5;
    const cy = TH * 0.5;

    // ring definition (less hazy)
    const baseAlpha = 0.12 + 0.22 * energy;   // base ring brightness
    const baseWidth = 2.4 + 1.4 * energy;     // base ring thickness

    // highlighted ring (walking strobe)
    const hiAlpha   = 0.62 + 0.22 * energy + 0.42 * pop;
    const hiWidth   = baseWidth + 2.2;

    // short tail (still crisp)
    const tailAlpha = 0.20 + 0.24 * energy + 0.10 * pop;
    const tailWidth = baseWidth + 1.0;

    // subtle alternating ring intensity to avoid “perfect vinyl” look
    tctx.lineCap = "round";

    // Base rings
    for (let i = 0; i < ringCount; i++) {
      const r = maxR - i * ringSpacing;
      if (r <= 0) break;

      const alt = (i % 2 === 0) ? 1.0 : 0.72;
      tctx.strokeStyle = `rgba(140, 210, 255, ${(baseAlpha * alt).toFixed(3)})`;
      tctx.lineWidth = baseWidth;

      tctx.beginPath();
      tctx.arc(cx, cy, r, 0, Math.PI * 2);
      tctx.stroke();
    }

    // Head ring
    const rHead = maxR - activeRing * ringSpacing;
    if (rHead > 0) {
      tctx.strokeStyle = `rgba(255,255,255, ${Math.min(1, hiAlpha).toFixed(3)})`;
      tctx.lineWidth = hiWidth;
      tctx.beginPath();
      tctx.arc(cx, cy, rHead, 0, Math.PI * 2);
      tctx.stroke();

      // Tail ring (one behind)
      const idx1 = (activeRing + 1) % ringCount;
      const rTail1 = maxR - idx1 * ringSpacing;
      tctx.strokeStyle = `rgba(190,230,255, ${Math.min(1, tailAlpha).toFixed(3)})`;
      tctx.lineWidth = tailWidth;
      tctx.beginPath();
      tctx.arc(cx, cy, rTail1, 0, Math.PI * 2);
      tctx.stroke();

      // Tail ring (two behind) - very faint but defined
      const idx2 = (activeRing + 2) % ringCount;
      const rTail2 = maxR - idx2 * ringSpacing;
      tctx.strokeStyle = `rgba(160,210,255, ${Math.min(1, tailAlpha * 0.55).toFixed(3)})`;
      tctx.lineWidth = tailWidth * 0.9;
      tctx.beginPath();
      tctx.arc(cx, cy, rTail2, 0, Math.PI * 2);
      tctx.stroke();
    }
  }

  function resetAll() {
    angle = 0;
    speed = 0;
    hue = 0;
    t = 0;
    spinner.style.transform = "rotate(0deg)";

    autoRamp = true;
    cancelCruise();

    setRunning(true);
    setTargetRPM(0);

    // reset tunnel stepping
    ringPhase = 0;
    activeRing = 0;

    modes[modeIndex].onEnter?.();

    writeTargetUI(targetRPM);
    writeRPMUI(0);
  }

  function updateBackground(dt, now) {
    // toggles
    tunnel.style.display = (bgOn && bgTunnelOn) ? "block" : "none";

    if (!bgOn) {
      bgAurora.style.opacity = "0";
      tctx.clearRect(0, 0, TW, TH);
      ctx.clearRect(0, 0, W, H);
      return;
    }

    const rpm = speed / 6;
    const energy = clamp(rpm / 600, 0, 1);
    const e = energy * INT;

    // strobe pop (shared with aurora + tunnel)
    let pop = 0;
    if (bgStrobe) {
      const beatHz = 1.2 + 10.5 * e;
      const st = Math.sin(t * Math.PI * 2 * beatHz);
      pop = Math.max(0, (st - 0.65) / 0.35);
      pop = pop * pop;
    }

    // WALKING STROBE LOCKED TO RPM:
    // revolutions/sec = rpm/60
    // One full outer->inner pass per revolution => steps/sec = (rpm/60)*ringCount
    const stepsPerSec = (rpm / 60) * ringCount;
    ringPhase = (ringPhase + stepsPerSec * dt) % ringCount;
    activeRing = Math.floor(ringPhase); // discrete = “line-by-line”

    // Tunnel scale swell (subtle)
    if (bgOn && bgTunnelOn) {
      const swell = 1 + 0.05 * (energy * INT);
      tunnel.style.transform = `translate(-50%, -50%) scale(${swell.toFixed(4)})`;
      drawTunnel(rpm, energy * INT, pop);
    } else {
      tunnel.style.transform = `translate(-50%, -50%)`;
    }

    // Aurora + filters are throttled (like your v3)
    if (now - bgLastWrite > 50) {
      bgLastWrite = now;

      const rate = 0.10 + 1.15 * e;
      bgPhase += dt * rate;
      const tri = 1 - Math.abs(((bgPhase % 1) * 2) - 1);

      if (bgAuroraOn) {
        const base = (hue + 30 + t * 8) % 360;
        const ah1 = base + 220 * tri;
        const ah2 = base + 180 - 220 * tri;
        const ah3 = base + 90 + 120 * (1 - tri);

        const aa1 = (0.10 + 0.28 * e) + pop * 0.14;
        const aa2 = (0.08 + 0.22 * e) + pop * 0.12;
        const aa3 = (0.06 + 0.18 * e) + pop * 0.10;

        const ax1 = 25 + 18 * Math.sin(t * (0.22 + 0.5 * e));
        const ay1 = 35 + 10 * Math.cos(t * (0.18 + 0.4 * e));
        const ax2 = 70 + 15 * Math.cos(t * (0.17 + 0.55 * e));
        const ay2 = 55 + 12 * Math.sin(t * (0.20 + 0.35 * e));
        const ax3 = 55 + 22 * Math.sin(t * (0.14 + 0.45 * e));
        const ay3 = 25 + 16 * Math.cos(t * (0.16 + 0.42 * e));

        bgAurora.style.opacity = "1";
        bgAurora.style.setProperty("--ah1", ah1.toFixed(1));
        bgAurora.style.setProperty("--ah2", ah2.toFixed(1));
        bgAurora.style.setProperty("--ah3", ah3.toFixed(1));
        bgAurora.style.setProperty("--aa1", aa1.toFixed(3));
        bgAurora.style.setProperty("--aa2", aa2.toFixed(3));
        bgAurora.style.setProperty("--aa3", aa3.toFixed(3));
        bgAurora.style.setProperty("--ax1", ax1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay1", ay1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax2", ax2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay2", ay2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax3", ax3.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay3", ay3.toFixed(1) + "%");

        const bright = 1 + 0.85 * pop;
        bgAurora.style.filter = `saturate(1.2) contrast(1.05) brightness(${bright.toFixed(2)})`;
      } else {
        bgAurora.style.opacity = "0";
      }
    }

    // Stars (unchanged except center is now 0.5)
    if (bgStarsOn) {
      ctx.fillStyle = "rgba(0,0,0,0.16)";
      ctx.fillRect(0, 0, W, H);

      const cx = W * 0.5;
      const cy = H * 0.5;

      const breathe = 0.6 + 0.4 * Math.sin(t * 1.2);
      const accel = (0.6 + 7.0 * (energy * energy) + 8.0 * (energy * energy * energy)) * INT;
      const warp = accel * breathe;

      for (const s of starsList) {
        s.tw += dt * (0.9 + 2.4 * energy) * (0.6 + s.z);
        const twinkle = 0.60 + 0.40 * Math.sin(s.tw);

        const dx = s.x - cx;
        const dy = s.y - cy;

        const swirl = 0.0040 * warp;
        const rx = dx * Math.cos(swirl) - dy * Math.sin(swirl);
        const ry = dx * Math.sin(swirl) + dy * Math.cos(swirl);

        const denom = (160 + 520 * s.z);
        const push = (warp * 220) * dt;
        s.x += (rx / denom) * push;
        s.y += (ry / denom) * push;

        if (s.x < -12) s.x = W + 12;
        if (s.x > W + 12) s.x = -12;
        if (s.y < -12) s.y = H + 12;
        if (s.y > H + 12) s.y = -12;

        const size  = s.r * (0.55 + 0.65 * (energy * INT)) * (0.85 + 0.55 * twinkle);
        const alpha = (0.10 + 0.35 * (energy * INT)) * (0.55 + 0.70 * twinkle);

        const hh = (hue + 110 * (s.z - 0.5)) % 360;
        ctx.fillStyle = `hsla(${(hh+360)%360}, 100%, 78%, 1)`;

        ctx.globalAlpha = Math.min(1, alpha * 0.45);
        ctx.beginPath();
        ctx.arc(s.x, s.y, size * 1.55, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = Math.min(1, alpha);
        ctx.beginPath();
        ctx.arc(s.x, s.y, Math.max(0.35, size * 0.60), 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1;
      }
    } else {
      ctx.clearRect(0, 0, W, H);
    }
  }

  // ----- UI EVENTS -----
  slider.addEventListener("input", () => {
    cancelCruise();
    autoRamp = false;
    setTargetRPM(Number(slider.value));
    writeTargetUI(targetRPM);
  });

  toggleBtn.addEventListener("click", () => setRunning(!running));
  resetBtn.addEventListener("click", resetAll);
  brakeBtn.addEventListener("click", brake);
  cruiseBtn.addEventListener("click", cruise);
  modeBtn.addEventListener("click", nextMode);

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") { e.preventDefault(); setRunning(!running); return; }
    if (e.key === "m" || e.key === "M") { nextMode(); return; }
    if (e.key === "r" || e.key === "R") { resetAll(); return; }
    if (e.key === "b" || e.key === "B") { brake(); return; }
    if (e.key === "c" || e.key === "C") { cruise(); return; }

    if (e.key === "g" || e.key === "G") { bgOn = !bgOn; return; }
    if (e.key === "a" || e.key === "A") { bgAuroraOn = !bgAuroraOn; return; }
    if (e.key === "t" || e.key === "T") { bgTunnelOn = !bgTunnelOn; return; }
    if (e.key === "f" || e.key === "F") { bgStarsOn = !bgStarsOn; return; }
