<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Yin Yang — Multi-Mode Spinner (v3.9: bg-clear fix + adaptive stars + faster tunnel)</title>

<style>
  html, body {
    margin: 0;
    background: black;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, sans-serif;
    color: #ddd;
  }

  /* ----- BACKGROUND LAYERS ----- */
  #bgAurora, #bgShade {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  /* Explicit layer stack */
  #bgAurora { z-index: 0; }
  #tunnel   { z-index: 1; }
  #bgShade  { z-index: 2; }
  #stars    { z-index: 3; }
  #container{ z-index: 4; position: relative; }

  #bgAurora{
    opacity: 0;
    background:
      radial-gradient(1200px 900px at var(--ax1, 30%) var(--ay1, 35%),
        hsla(var(--ah1, 180), 100%, 55%, var(--aa1, 0.22)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 60%),
      radial-gradient(1000px 800px at var(--ax2, 70%) var(--ay2, 55%),
        hsla(var(--ah2, 260), 100%, 55%, var(--aa2, 0.18)) 0%,
        hsla(var(--ah1, 180), 100%, 50%, 0.00) 62%),
      radial-gradient(900px 700px at var(--ax3, 55%) var(--ay3, 25%),
        hsla(var(--ah3, 40), 100%, 55%, var(--aa3, 0.14)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 65%);
    mix-blend-mode: screen;
    will-change: background, filter;
  }

  #tunnel{
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    transform-origin: 50% 50%;
    pointer-events: none;
    mix-blend-mode: screen;
    will-change: transform;
    display: none;
  }

  #bgShade{
    background: radial-gradient(circle at 50% 50%,
      rgba(0,0,0,0.05) 0%,
      rgba(0,0,0,0.55) 65%,
      rgba(0,0,0,0.95) 100%);
  }

  #stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    mix-blend-mode: screen;
    display: block;
    width: 100%;
    height: 100%;
  }

  /* ----- TOP BACKGROUND BUTTONS ----- */
  #bgUI {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    user-select: none;
  }

  .chip {
    background: rgba(10,10,10,0.55);
    border: 1px solid rgba(120,120,120,0.35);
    color: #ddd;
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    touch-action: manipulation;
  }
  .chip:active { transform: translateY(1px); }
  .chip.off {
    opacity: 0.45;
    border-color: rgba(120,120,120,0.20);
  }

  /* ----- SPINNER ----- */
  #container {
    width: 420px;
    height: 420px;
  }

  @media (max-width: 520px) {
    #container { width: 320px; height: 320px; }
    #hud { bottom: -140px; }
    input[type="range"] { width: 210px; }
    #bgUI { top: 8px; left: 8px; gap: 6px; }
    .chip { padding: 6px 9px; font-size: 12px; }
  }

  svg {
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
    transform-box: fill-box;
    will-change: transform, filter;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  #hud {
    position: absolute;
    bottom: -120px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    opacity: 0.88;
    user-select: none;
  }

  .row { margin-top: 6px; }
  input[type="range"] { width: 240px; }

  .small {
    font-size: 12px;
    opacity: 0.72;
    margin-top: 8px;
    line-height: 1.4;
  }

  kbd {
    background: #222;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 1px 5px;
  }

  .controls {
    display: inline-flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: #111;
    color: #ddd;
    border: 1px solid #444;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
    touch-action: manipulation;
  }

  button:active { transform: translateY(1px); }
  .paused { opacity: 0.6; }
</style>
</head>

<body>

<!-- TOP BACKGROUND BUTTONS (no master BG) -->
<div id="bgUI" aria-label="Background toggles">
  <button class="chip off" id="btnAurora" type="button" title="Toggle aurora (A)">Aurora</button>
  <button class="chip off" id="btnTunnel" type="button" title="Toggle tunnel (T)">Tunnel</button>
  <button class="chip off" id="btnStars"  type="button" title="Toggle stars (F)">Stars</button>
  <button class="chip off" id="btnStrobe" type="button" title="Toggle strobe beat (S)">Strobe</button>
</div>

<canvas id="stars"></canvas>
<div id="bgAurora"></div>
<canvas id="tunnel"></canvas>
<div id="bgShade"></div>

<div id="container">
  <svg id="spinner" viewBox="-100 -100 200 200" aria-label="Yin Yang spinner" role="img">
    <defs>
      <filter id="warp" x="-30%" y="-30%" width="160%" height="160%">
        <feTurbulence id="turb" type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="2" />
        <feDisplacementMap id="disp" in="SourceGraphic" scale="0" />
      </filter>
    </defs>

    <g id="art">
      <circle id="outer" r="100" fill="white"/>
      <path id="half" d="
        M 0 -100
        A 100 100 0 0 1 0 100
        A 50 50 0 0 0 0 0
        A 50 50 0 0 1 0 -100
      " fill="black"/>
      <circle id="lobe1" cx="0" cy="-50" r="50" fill="white"/>
      <circle id="lobe2" cx="0" cy="50"  r="50" fill="black"/>
      <circle id="dot1" cx="0" cy="-42" r="14" fill="black"/>
      <circle id="dot2" cx="0" cy="42"  r="14" fill="white"/>
    </g>
  </svg>

  <div id="hud">
    <div>
      <strong>RPM:</strong>
      <span id="rpm">0.0</span>
      <span id="state"></span>
    </div>

    <div class="row">
      <input id="rpmSlider" type="range" min="0" max="600" step="1" value="0" />
      <span><strong>Target:</strong> <span id="rpmTarget">0</span></span>
    </div>

    <div class="controls">
      <button id="toggleBtn" type="button">Start</button>
      <button id="modeBtn" type="button">Mode</button>
    </div>

    <div class="small">
      <strong>Mode:</strong> <span id="modeName"></span><br>
      <kbd>Space</kbd> start/stop · <kbd>↑</kbd>/<kbd>↓</kbd> speed · <kbd>M</kbd> mode<br>
      <span style="opacity:.8">
        <kbd>A</kbd> aurora · <kbd>T</kbd> tunnel · <kbd>F</kbd> stars · <kbd>S</kbd> strobe
      </span>
    </div>
  </div>
</div>

<script>
  const spinner = document.getElementById("spinner");
  const art = document.getElementById("art");

  const outer = document.getElementById("outer");
  const half  = document.getElementById("half");
  const lobe1 = document.getElementById("lobe1");
  const lobe2 = document.getElementById("lobe2");
  const dot1  = document.getElementById("dot1");
  const dot2  = document.getElementById("dot2");

  const turb = document.getElementById("turb");
  const disp = document.getElementById("disp");

  const rpmEl = document.getElementById("rpm");
  const stateEl = document.getElementById("state");
  const slider = document.getElementById("rpmSlider");
  const rpmTargetEl = document.getElementById("rpmTarget");

  const toggleBtn = document.getElementById("toggleBtn");
  const modeBtn = document.getElementById("modeBtn");
  const modeNameEl = document.getElementById("modeName");

  const bgAurora = document.getElementById("bgAurora");

  const stars = document.getElementById("stars");
  const ctx = stars.getContext("2d", { alpha: true });

  const tunnel = document.getElementById("tunnel");
  const tctx = tunnel.getContext("2d", { alpha: true });

  // BG UI buttons (no master)
  const btnAurora = document.getElementById("btnAurora");
  const btnTunnel = document.getElementById("btnTunnel");
  const btnStars  = document.getElementById("btnStars");
  const btnStrobe = document.getElementById("btnStrobe");

  // ----- STATE -----
  let angle = 0;
  let speed = 0;            // deg/sec
  let running = false;      // no auto-start

  let targetRPM = 0;
  let autoRamp = false;     // Start ramps up

  let last = performance.now();
  let hue = 0;
  let t = 0;

  // Adaptive performance bias (no UI)
  let perfSlow = 0; // 0..1

  const steps = 24;
  const stepSize = 360 / steps;

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
  function rpmToDeg(rpm) { return rpm * 6; }
  const MAX_RPM = 600;

  // Intensity
  const INT = 0.75;

  // ---- SAFETY HELPERS ----
  const TAU = Math.PI * 2;
  function safeNum(x, fallback = 0) { return Number.isFinite(x) ? x : fallback; }
  function normHue(h) {
    if (!Number.isFinite(h)) return 0;
    h %= 360;
    if (h < 0) h += 360;
    return h;
  }
  function respawnStar(s) {
    s.x  = Math.random() * W;
    s.y  = Math.random() * H;
    s.z  = Math.random();
    s.r  = 0.25 + Math.random() * 0.60;
    s.tw = Math.random() * TAU;
  }

  // Visual BG only (strobe is a modifier, not a visual layer)
  function anyVisualBgOn() {
    return bgAuroraOn || bgTunnelOn || bgStarsOn;
  }

  // ----- UI THROTTLE / CACHES -----
  let uiLastWrite = 0;
  let lastShownRPM = "";
  let lastShownTarget = "";
  let lastSlider = -1;

  function writeTargetUI(rpm) {
    const rounded = Math.round(rpm);
    if (rounded !== lastSlider) {
      slider.value = String(rounded);
      lastSlider = rounded;
    }
    const s = String(rounded);
    if (s !== lastShownTarget) {
      rpmTargetEl.textContent = s;
      lastShownTarget = s;
    }
  }

  function writeRPMUI(rpmFloat) {
    const s = rpmFloat.toFixed(1);
    if (s !== lastShownRPM) {
      rpmEl.textContent = s;
      lastShownRPM = s;
    }
  }

  function updateColors() {
    outer.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
    half.setAttribute("fill",  `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    lobe1.setAttribute("fill", `hsl(${((hue+90)%360+360)%360},100%,60%)`);
    lobe2.setAttribute("fill", `hsl(${((hue+270)%360+360)%360},100%,60%)`);
    dot1.setAttribute("fill",  `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    dot2.setAttribute("fill",  `hsl(${(hue%360+360)%360},100%,60%)`);
  }

  function classicColors() {
    outer.setAttribute("fill", "white");
    half.setAttribute("fill", "black");
    lobe1.setAttribute("fill", "white");
    lobe2.setAttribute("fill", "black");
    dot1.setAttribute("fill", "black");
    dot2.setAttribute("fill", "white");
  }

  function setDotStroke(on) {
    if (on) {
      dot1.setAttribute("stroke", "white");
      dot1.setAttribute("stroke-width", "2");
      dot2.setAttribute("stroke", "black");
      dot2.setAttribute("stroke-width", "2");
    } else {
      dot1.removeAttribute("stroke");
      dot1.removeAttribute("stroke-width");
      dot2.removeAttribute("stroke");
      dot2.removeAttribute("stroke-width");
    }
  }

  function setRunning(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? "Stop" : "Start";
    stateEl.textContent = running ? "" : " (stopped)";
    rpmEl.classList.toggle("paused", !running);

    // autoRamp only when starting
    autoRamp = running;
  }

  function setTargetRPM(rpm) { targetRPM = clamp(rpm, 0, MAX_RPM); }

  function clearTrippyFX() {
    art.removeAttribute("filter");
    spinner.style.filter = "";
    spinner.style.mixBlendMode = "";
    spinner.style.transformOrigin = "50% 50%";
  }

  // ----- SPINNER MODES -----
  let modeIndex = 0; // Classic B/W start
  const modes = [
    { name: "Classic (B/W)", onEnter(){ clearTrippyFX(); setDotStroke(false); classicColors(); }, update(dt){} },
    {
      name: "Indexed Color (Stepped)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        hue = Math.round(hue / stepSize) * stepSize;
        updateColors();
      }
    },
    {
      name: "Outlined Eyes (Smooth Hue)",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); },
      update(dt){ hue += (speed * 0.02 * dt); updateColors(); }
    },
    {
      name: "Neon Glow Pulse",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); spinner.style.mixBlendMode = "screen"; },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const pulse = 0.5 + 0.5 * Math.sin(t * 2.2);
        const glow = clamp((rpm / 600) * 18 + pulse * 8, 0, 28);
        spinner.style.filter = `drop-shadow(0 0 ${glow.toFixed(1)}px hsl(${(hue%360+360)%360},100%,60%))`;
      }
    },
    {
      name: "Warp Field (Liquid)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); art.setAttribute("filter","url(#warp)"); },
      update(dt){
        hue += (speed * 0.018 * dt);
        updateColors();
        const rpm = speed / 6;
        const energy = rpm / 600;
        const wobble = 0.5 + 0.5 * Math.sin(t * 1.7);
        const bf = 0.010 + 0.012 * (0.35 + wobble) * energy;
        turb.setAttribute("baseFrequency", bf.toFixed(4));
        const scale = 2 + 28 * energy * (0.35 + wobble);
        disp.setAttribute("scale", scale.toFixed(1));
      }
    },
    {
      name: "Strobe Invert (Beat)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const beatHz = 2 + 10 * (rpm / 600);
        const strobe = (Math.sin(t * Math.PI * 2 * beatHz) > 0.4);
        const wob = 1 + 0.012 * Math.sin(t * 3.3);
        spinner.style.filter = strobe ? "invert(1) contrast(1.15)" : "contrast(1.05)";
        spinner.style.transform = `rotate(${angle}deg) scale(${wob.toFixed(4)})`;
      }
    }
  ];

  function applyMode(i) {
    modeIndex = (i + modes.length) % modes.length;
    modeNameEl.textContent = modes[modeIndex].name;
    modes[modeIndex].onEnter?.();
  }
  function nextMode(){ applyMode(modeIndex + 1); }

  // ----- BACKGROUND FLAGS (no master) -----
  let bgAuroraOn = false;
  let bgTunnelOn = false;
  let bgStarsOn  = false;
  let bgStrobe   = false;

  function syncBgButtons() {
    btnAurora.classList.toggle("off", !bgAuroraOn);
    btnTunnel.classList.toggle("off", !bgTunnelOn);
    btnStars.classList.toggle("off",  !bgStarsOn);
    btnStrobe.classList.toggle("off", !bgStrobe);
  }

  function clearAllBgBuffers() {
    bgAurora.style.opacity = "0";
    tunnel.style.display = "none";
    tctx.clearRect(0, 0, TW || 0, TH || 0);

    trailDebt = 0;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.clearRect(0, 0, W || 0, H || 0);
  }

  btnAurora.addEventListener("click", () => {
    bgAuroraOn = !bgAuroraOn;
    if (!anyVisualBgOn()) clearAllBgBuffers();
    syncBgButtons();
  });

  btnTunnel.addEventListener("click", () => {
    bgTunnelOn = !bgTunnelOn;
    if (!anyVisualBgOn()) clearAllBgBuffers();
    syncBgButtons();
  });

  btnStars.addEventListener("click", () => {
    bgStarsOn = !bgStarsOn;
    if (bgStarsOn) {
      if (!W || !H || starsList.length === 0) resizeStars();
      trailDebt = 0;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0, 0, W, H);
    } else {
      if (!anyVisualBgOn()) clearAllBgBuffers();
    }
    syncBgButtons();
  });

  btnStrobe.addEventListener("click", () => {
    bgStrobe = !bgStrobe;
    // Don't clear here; strobe alone shouldn't preserve visuals anyway due to anyVisualBgOn()
    syncBgButtons();
  });

  // ----- BACKGROUND THROTTLES -----
  let bgLastWrite = 0;
  let bgPhase = 0;

  // Starfield
  let W = 0, H = 0, DPR = 1;
  let starsList = [];
  let trailDebt = 0;

  function resizeStars() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    stars.width = Math.floor(W * DPR);
    stars.height = Math.floor(H * DPR);
    stars.style.width = W + "px";
    stars.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    const base = Math.floor((W * H) / 9000);
    const count = clamp(Math.floor(base * 1.9), 220, 620);

    starsList = [];
    for (let i = 0; i < count; i++) {
      starsList.push({
        x: Math.random() * W,
        y: Math.random() * H,
        z: Math.random(),
        r: 0.25 + Math.random() * 0.60,
        tw: Math.random() * TAU
      });
    }

    for (const s of starsList) respawnStar(s);
    trailDebt = 0;
  }

  // ----- TUNNEL CANVAS -----
  let TW = 0, TH = 0, TDPR = 1;
  let ringSpacing = 16;
  let ringCount = 0;
  let maxR = 0;

  let ringPhase = 0;        // FLOAT phase (we draw by radius, not index)
  let tunnelLastDraw = 0;

  // ----- TUNNEL TUNING -----
  // Faster ring progression:
  const TUNNEL_RINGS_PER_REV = 18;     // was 12
  const TUNNEL_SPEED_MULT    = 1.35;   // extra shove

  // 0 = draw every frame; 16 = ~60fps; 33 = ~30fps (saves CPU)
  const TUNNEL_DRAW_EVERY_MS = 0;

  const baseTunnel = document.createElement("canvas");
  const bctx = baseTunnel.getContext("2d", { alpha: true });
  let baseDirty = true;

  function resizeTunnel() {
    TDPR = 1;
    const vmax = Math.max(window.innerWidth || 1, window.innerHeight || 1);
    const side = Math.max(1, Math.floor(vmax * 1.8));

    TW = side;
    TH = side;

    tunnel.style.width = side + "px";
    tunnel.style.height = side + "px";

    tunnel.width  = Math.floor(TW * TDPR);
    tunnel.height = Math.floor(TH * TDPR);

    tctx.setTransform(TDPR, 0, 0, TDPR, 0, 0);

    const cx = TW * 0.5;
    const cy = TH * 0.5;
    maxR = Math.hypot(cx, cy);

    ringCount = Math.max(18, Math.floor(maxR / ringSpacing));

    baseTunnel.width  = tunnel.width;
    baseTunnel.height = tunnel.height;
    bctx.setTransform(TDPR, 0, 0, TDPR, 0, 0);
    baseDirty = true;
  }

  function rebuildBaseTunnel() {
    if (!Number.isFinite(TW) || !Number.isFinite(TH) || TW <= 0 || TH <= 0) return;
    if (!Number.isFinite(ringCount) || ringCount <= 0) return;

    baseDirty = false;
    bctx.clearRect(0, 0, TW, TH);

    const cx = TW * 0.5;
    const cy = TH * 0.5;

    const baseAlpha = 0.085;
    const baseWidth = 2.1;

    bctx.lineCap = "round";

    for (let i = 0; i < ringCount; i++) {
      const r = maxR - i * ringSpacing;
      if (r <= 0) break;

      const alt = (i % 2 === 0) ? 1.0 : 0.70;
      bctx.strokeStyle = `rgba(110,200,255, ${(baseAlpha * alt).toFixed(3)})`;
      bctx.lineWidth = baseWidth;

      bctx.beginPath();
      bctx.arc(cx, cy, r, 0, Math.PI * 2);
      bctx.stroke();
    }
  }

  function drawTunnel(energy, pop) {
    if (baseDirty) rebuildBaseTunnel();

    tctx.clearRect(0, 0, TW, TH);

    const baseGain = 0.70 + 0.55 * energy;
    tctx.globalAlpha = clamp(baseGain, 0.60, 1.0);
    tctx.drawImage(baseTunnel, 0, 0);
    tctx.globalAlpha = 1;

    const cx = TW * 0.5;
    const cy = TH * 0.5;

    const hh1 = normHue(hue + 185);
    const hh2 = normHue(hue + 315);

    const hiAlpha = 0.55 + 0.20 * energy + 0.55 * pop;
    const hiWidth = 4.6 + 2.9 * energy;

    const tailAlpha = 0.20 + 0.16 * energy + 0.22 * pop;
    const tailWidth = 3.2 + 1.5 * energy;

    tctx.lineCap = "round";

    const rHead  = maxR - ringPhase * ringSpacing;
    const rTail1 = rHead - ringSpacing;
    const rTail2 = rHead - 2 * ringSpacing;

    if (rHead > 0) {
      tctx.strokeStyle = `hsla(${hh1},100%,72%,${Math.min(1, hiAlpha).toFixed(3)})`;
      tctx.lineWidth = hiWidth;
      tctx.beginPath();
      tctx.arc(cx, cy, rHead, 0, Math.PI * 2);
      tctx.stroke();

      tctx.strokeStyle = `rgba(255,255,255,${Math.min(1, (0.35 + 0.75 * pop + 0.25 * energy)).toFixed(3)})`;
      tctx.lineWidth = Math.max(1.2, hiWidth * 0.28);
      tctx.beginPath();
      tctx.arc(cx, cy, rHead - 0.6, 0, Math.PI * 2);
      tctx.stroke();
    }

    if (rTail1 > 0) {
      tctx.strokeStyle = `hsla(${hh1},100%,74%,${Math.min(1, tailAlpha).toFixed(3)})`;
      tctx.lineWidth = tailWidth;
      tctx.beginPath();
      tctx.arc(cx, cy, rTail1, 0, Math.PI * 2);
      tctx.stroke();
    }

    if (rTail2 > 0) {
      tctx.strokeStyle = `hsla(${hh2},100%,72%,${Math.min(1, tailAlpha * 0.55).toFixed(3)})`;
      tctx.lineWidth = tailWidth * 0.9;
      tctx.beginPath();
      tctx.arc(cx, cy, rTail2, 0, Math.PI * 2);
      tctx.stroke();
    }
  }

  // ----- STAR HELPERS -----
  function drawStarDot(x, y, size, alpha, hh) {
    ctx.save();
    ctx.fillStyle = `hsla(${hh},100%,78%,1)`;

    ctx.globalAlpha = Math.min(1, alpha * 0.40);
    ctx.beginPath();
    ctx.arc(x, y, size * 1.9, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = Math.min(1, alpha);
    ctx.beginPath();
    ctx.arc(x, y, Math.max(0.5, size * 0.70), 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawStarStreak(x, y, vx, vy, len, width, alpha, hh) {
    ctx.save();

    const mag = Math.hypot(vx, vy) || 1;
    const ux = vx / mag;
    const uy = vy / mag;

    const x2 = x - ux * len;
    const y2 = y - uy * len;

    ctx.strokeStyle = `hsla(${hh},100%,78%,1)`;
    ctx.lineWidth = width;
    ctx.globalAlpha = Math.min(1, alpha);

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    ctx.restore();
  }

  // ----- BACKGROUND UPDATE -----
  function updateBackground(dt, now) {
    if (!anyVisualBgOn()) {
      clearAllBgBuffers();
      return;
    }

    tunnel.style.display = bgTunnelOn ? "block" : "none";

    const rpm = speed / 6;
    const energy = clamp(rpm / 600, 0, 1);
    const e = energy * INT;

    // strobe pop (modifier)
    let pop = 0;
    if (bgStrobe) {
      const beatHz = 1.2 + 10.5 * e;
      const st = Math.sin(t * Math.PI * 2 * beatHz);
      pop = Math.max(0, (st - 0.65) / 0.35);
      pop = pop * pop;
    }

    // ---- tunnel: faster progression + oscillation ----
    if (bgTunnelOn && ringCount > 0 && maxR > 0) {
      const revPerSec = (speed / 360);

      // harder ramp (slow early, ramps more later)
      const ramp = 0.22 + 0.78 * Math.pow(energy, 3.2);

      // subtle oscillation that increases with speed
      const oscHz  = 0.35 + 2.2 * energy;
      const oscAmp = (0.03 + 0.15 * energy) * INT;
      const osc    = 1 + oscAmp * Math.sin(t * TAU * oscHz);

      // speed-up multiplier
      const ringsPerSec = revPerSec * TUNNEL_RINGS_PER_REV * ramp * osc * TUNNEL_SPEED_MULT;

      ringPhase = (ringPhase - ringsPerSec * dt) % ringCount;
      if (ringPhase < 0) ringPhase += ringCount;

      const swell = 1 + 0.05 * (energy * INT);
      const wob   = 1 + 0.02 * Math.sin(angle * Math.PI / 180);
      tunnel.style.transform = `translate(-50%, -50%) scale(${(swell*wob).toFixed(4)})`;

      const okToDraw =
        (TUNNEL_DRAW_EVERY_MS <= 0) ||
        (now - tunnelLastDraw >= TUNNEL_DRAW_EVERY_MS);

      if (okToDraw) {
        drawTunnel(energy * INT, pop);
        tunnelLastDraw = now;
      }
    } else {
      tctx.clearRect(0, 0, TW || 0, TH || 0);
      tunnel.style.transform = `translate(-50%, -50%)`;
    }

    // ---- aurora ----
    if (now - bgLastWrite > 50) {
      bgLastWrite = now;

      if (bgAuroraOn) {
        const rate = 0.10 + 1.15 * e;
        bgPhase += dt * rate;
        const tri = 1 - Math.abs(((bgPhase % 1) * 2) - 1);

        const base = (hue + 30 + t * 8) % 360;
        const ah1 = base + 220 * tri;
        const ah2 = base + 180 - 220 * tri;
        const ah3 = base + 90 + 120 * (1 - tri);

        const aa1 = (0.10 + 0.28 * e) + pop * 0.14;
        const aa2 = (0.08 + 0.22 * e) + pop * 0.12;
        const aa3 = (0.06 + 0.18 * e) + pop * 0.10;

        const ax1 = 25 + 18 * Math.sin(t * (0.22 + 0.5 * e));
        const ay1 = 35 + 10 * Math.cos(t * (0.18 + 0.4 * e));
        const ax2 = 70 + 15 * Math.cos(t * (0.17 + 0.55 * e));
        const ay2 = 55 + 12 * Math.sin(t * (0.20 + 0.35 * e));
        const ax3 = 55 + 22 * Math.sin(t * (0.14 + 0.45 * e));
        const ay3 = 25 + 16 * Math.cos(t * (0.16 + 0.42 * e));

        bgAurora.style.opacity = "1";
        bgAurora.style.setProperty("--ah1", ah1.toFixed(1));
        bgAurora.style.setProperty("--ah2", ah2.toFixed(1));
        bgAurora.style.setProperty("--ah3", ah3.toFixed(1));
        bgAurora.style.setProperty("--aa1", aa1.toFixed(3));
        bgAurora.style.setProperty("--aa2", aa2.toFixed(3));
        bgAurora.style.setProperty("--aa3", aa3.toFixed(3));
        bgAurora.style.setProperty("--ax1", ax1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay1", ay1.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax2", ax2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay2", ay2.toFixed(1) + "%");
        bgAurora.style.setProperty("--ax3", ax3.toFixed(1) + "%");
        bgAurora.style.setProperty("--ay3", ay3.toFixed(1) + "%");

        const bright = 1 + 0.85 * pop;
        bgAurora.style.filter = `saturate(1.2) contrast(1.05) brightness(${bright.toFixed(2)})`;
      } else {
        bgAurora.style.opacity = "0";
      }
    }

    // ---- stars (hyperspace starts @450 rpm) ----
    if (bgStarsOn) {
      const cx = W * 0.5;
      const cy = H * 0.5;

      speed = safeNum(speed, 0);
      hue   = safeNum(hue, 0);

      const energyS = clamp((speed / 6) / 600, 0, 1);

      const HYPER_START = 0.75;
      const hyper = clamp((energyS - HYPER_START) / (1 - HYPER_START), 0, 1);
      const hyper2 = hyper * hyper * hyper;

      // "cold" space until you’re really near hyper
      const crispMode = (hyper < 0.04); // was 0.06

      // ----- CLEARING / TRAILS -----
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";

      if (crispMode) {
        trailDebt = 0;
        ctx.clearRect(0, 0, W, H);
      } else {
        const fade = (0.04 + 0.10 * hyper2);
        trailDebt += fade;

        if (trailDebt > 1.25) {
          ctx.clearRect(0, 0, W, H);
          trailDebt = 0;
        } else {
          ctx.fillStyle = `rgba(0,0,0,${fade})`;
          ctx.fillRect(0, 0, W, H);
        }
      }

      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 1;

      // ===== MONOTONIC ACCEL (NO BREATHING) + MEDIUM LAST 1/5 PUNCH =====
      const e2 = energyS * energyS;
      const e3 = e2 * energyS;

      // your original accel curve (clean, always increasing)
      const accel = (0.9 + 6.5 * e2 + 8.0 * e3) * INT;

      // Medium "last 1/5th" boost: only in the final 20% of hyper (hyper 0.8..1.0)
      let lastGate = (hyper - 0.80) / 0.20;      // 0..1 in last fifth
      lastGate = clamp(lastGate, 0, 1);
      lastGate = lastGate * lastGate;            // ease-in so it ramps nicely

      const charge = 1.0 + 1.20 * lastGate;      // medium: up to ~2.2x at the very end
      const warp   = accel * charge;
      // ================================================================

      const pad = 60;

      // Adaptive draw reduction when FPS drops
      const extra = Math.floor(perfSlow * 4); // 0..4
      const drawStride = 1 + Math.floor(hyper2 * 4.0) + extra;

      let idx = 0;

      for (const s of starsList) {
        if (!Number.isFinite(s.x) || !Number.isFinite(s.y) || !Number.isFinite(s.z) || !Number.isFinite(s.r) || !Number.isFinite(s.tw)) {
          respawnStar(s);
        }

        // keep phase moving, but make the star *rendering* cold (no strong pulsing)
        s.tw += dt * (0.9 + 2.4 * energyS) * (0.6 + s.z);

        // cold twinkle: basically steady (no “breathing” feel)
        const twinkle = 0.97 + 0.03 * Math.sin(s.tw);

        const dx = s.x - cx;
        const dy = s.y - cy;

        const swirl = 0.0040 * warp;
        const cs = Math.cos(swirl), sn = Math.sin(swirl);
        const rx = dx * cs - dy * sn;
        const ry = dx * sn + dy * cs;

        const denom = (160 + 520 * s.z);
        const push = (warp * 220) * dt;

        const vx = (rx / denom) * push;
        const vy = (ry / denom) * push;

        if (!Number.isFinite(vx) || !Number.isFinite(vy)) {
          respawnStar(s);
          idx++;
          continue;
        }

        s.x += vx;
        s.y += vy;

        if (s.x < -pad || s.x > W + pad || s.y < -pad || s.y > H + pad) {
          respawnStar(s);
          idx++;
          continue;
        }

        const shouldDraw = (idx % drawStride === 0);
        idx++;
        if (!shouldDraw) continue;

        const size  = s.r * (0.90 + 0.55 * (energyS * INT)) * (0.92 + 0.20 * twinkle);
        const alphaBase = (0.42 + 0.42 * (energyS * INT)) * (0.86 + 0.18 * twinkle);
        const alpha = alphaBase * (1.0 - 0.28 * hyper2);

        const hhn = normHue(hue + 110 * (s.z - 0.5));

        if (!crispMode) {
          const speedPx = Math.hypot(vx, vy);
          const len = clamp(
            (10 + 135 * hyper2) * (0.35 + 0.95 * s.z) * (0.35 + 2.0 * speedPx),
            8, 220
          );
          const w   = clamp(
            (0.8 + 2.2 * hyper) * (0.35 + 0.85 * s.z),
            0.7, 3.4
          );

          drawStarStreak(
            s.x, s.y, vx, vy,
            len, w,
            Math.min(1, alpha * (0.52 + 0.78 * hyper)),
            hhn
          );
        }

        drawStarDot(s.x, s.y, size, alpha, hhn);
      }

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
    } else {
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0, 0, W || 0, H || 0);
      trailDebt = 0;
    }
  }

  // ----- UI EVENTS -----
  slider.addEventListener("input", () => {
    autoRamp = false;
    setTargetRPM(Number(slider.value));
    writeTargetUI(targetRPM);
  });

  toggleBtn.addEventListener("click", () => setRunning(!running));
  modeBtn.addEventListener("click", nextMode);

  document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive: false });

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") { e.preventDefault(); setRunning(!running); return; }
    if (e.key === "m" || e.key === "M") { nextMode(); return; }

    if (e.key === "a" || e.key === "A") { btnAurora.click(); return; }
    if (e.key === "t" || e.key === "T") { btnTunnel.click(); return; }
    if (e.key === "f" || e.key === "F") { btnStars.click(); return; }
    if (e.key === "s" || e.key === "S") { btnStrobe.click(); return; }

    if (e.key === "ArrowUp")   { autoRamp = false; setTargetRPM(targetRPM + 5); writeTargetUI(targetRPM); return; }
    if (e.key === "ArrowDown") { autoRamp = false; setTargetRPM(targetRPM - 5); writeTargetUI(targetRPM); return; }
  });

  // ----- RESIZE HOOKS -----
  window.addEventListener("resize", () => {
    resizeTunnel();
    rebuildBaseTunnel();
    resizeStars();
  });

  // ----- ANIMATION LOOP -----
  function tick(now) {
    let dt = (now - last) / 1000;
    last = now;

    dt = Math.min(dt, 0.05);
    t += dt;

    // Adaptive performance bias
    const targetSlow = dt > 0.022 ? 1 : 0; // ~45fps threshold
    perfSlow += (targetSlow - perfSlow) * 0.05;

    if (running) {
      if (autoRamp) {
        const rampSeconds = 35;
        const rampRate = MAX_RPM / rampSeconds;

        const prog = clamp(targetRPM / MAX_RPM, 0, 1);
        const ease = 0.35 + 0.65 * (prog * prog);

        setTargetRPM(targetRPM + rampRate * dt * ease);
        if (targetRPM >= MAX_RPM) autoRamp = false;
      }

      const targetSpeed = rpmToDeg(targetRPM);

      const accel = autoRamp ? 170 : 360;
      const decel = 900;
      const maxAccel = (targetSpeed < speed) ? decel : accel;

      const delta = targetSpeed - speed;
      const step = Math.sign(delta) * Math.min(Math.abs(delta), maxAccel * dt);
      speed += step;

      angle = (angle + speed * dt) % 360;

      if (modes[modeIndex].name !== "Strobe Invert (Beat)") {
        spinner.style.transform = `rotate(${angle}deg)`;
      }

      writeRPMUI(speed / 6);
      modes[modeIndex].update?.(dt);
    } else {
      writeRPMUI(speed / 6);
    }

    updateBackground(dt, now);

    if (now - uiLastWrite > 50) {
      uiLastWrite = now;
      writeTargetUI(targetRPM);
    }

    requestAnimationFrame(tick);
  }

  // init
  applyMode(modeIndex);

  resizeTunnel();
  rebuildBaseTunnel();
  resizeStars();

  setTargetRPM(0);
  writeTargetUI(0);
  writeRPMUI(0);
  setRunning(false);

  // start with no BG FX
  bgAuroraOn = false;
  bgTunnelOn = false;
  bgStarsOn  = false;
  bgStrobe   = false;
  syncBgButtons();
  clearAllBgBuffers();

  requestAnimationFrame(tick);
</script>

</body>
</html>
