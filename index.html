<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Yin Yang — Multi-Mode Spinner (Factory Loaded v3)</title>

<style>
  html, body {
    margin: 0;
    background: black;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, sans-serif;
    color: #ddd;
  }

  /* ----- BACKGROUND LAYERS ----- */
  /* IMPORTANT: bgTunnel is NOT in this group (because inset:0 forces full-screen rectangle) */
  #bgAurora, #bgShade {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  /* Explicit layer stack */
  #bgAurora { z-index: 0; }
  #bgTunnel { z-index: 1; }
  #bgShade  { z-index: 2; }      /* dark vignette */
  #stars    { z-index: 3; }      /* stars ABOVE vignette */
  #container{ z-index: 4; position: relative; }

  #bgAurora{
    opacity: 1;
    background:
      radial-gradient(1200px 900px at var(--ax1, 30%) var(--ay1, 35%),
        hsla(var(--ah1, 180), 100%, 55%, var(--aa1, 0.22)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 60%),
      radial-gradient(1000px 800px at var(--ax2, 70%) var(--ay2, 55%),
        hsla(var(--ah2, 260), 100%, 55%, var(--aa2, 0.18)) 0%,
        hsla(var(--ah1, 180), 100%, 50%, 0.00) 62%),
      radial-gradient(900px 700px at var(--ax3, 55%) var(--ay3, 25%),
        hsla(var(--ah3, 40), 100%, 55%, var(--aa3, 0.14)) 0%,
        hsla(var(--ah2, 260), 100%, 50%, 0.00) 65%);
    mix-blend-mode: screen;
    will-change: background, filter;
  }

  /* Tunnel is a big centered square so rotation never shows “rectangle corners” */
  #bgTunnel{
    position: fixed;
    inset: auto;            /* cancels inset:0 behavior */
    left: 50%;
    top: 45%;
    width: 180vmax;
    height: 180vmax;
    transform: translate(-50%, -50%);
    transform-origin: 50% 50%;
    pointer-events: none;

    opacity: 1;
    background:
      repeating-radial-gradient(circle at var(--tcx, 50%) var(--tcy, 45%),
        hsla(var(--th1, 200), 100%, 55%, var(--ta, 0.10)) 0px,
        hsla(var(--th2, 320), 100%, 55%, var(--ta, 0.06)) 10px,
        hsla(var(--th1, 200), 100%, 55%, 0.00) 22px);
    mix-blend-mode: screen;
    will-change: background, filter, transform;
  }

  #bgShade{
    background: radial-gradient(circle at 50% 45%,
      rgba(0,0,0,0.05) 0%,
      rgba(0,0,0,0.65) 65%,
      rgba(0,0,0,0.95) 100%);
  }

  #stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    mix-blend-mode: screen;  /* makes stars pop over shade/aurora/tunnel */
  }

  /* ----- SPINNER ----- */
  #container {
    width: 420px;
    height: 420px;
  }

  @media (max-width: 520px) {
    #container { width: 320px; height: 320px; }
    #hud { bottom: -140px; }
    input[type="range"] { width: 210px; }
  }

  svg {
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
    transform-box: fill-box;
    will-change: transform, filter;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  #hud {
    position: absolute;
    bottom: -120px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    opacity: 0.88;
    user-select: none;
  }

  .row { margin-top: 6px; }
  input[type="range"] { width: 240px; }

  .small {
    font-size: 12px;
    opacity: 0.72;
    margin-top: 8px;
    line-height: 1.4;
  }

  kbd {
    background: #222;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 1px 5px;
  }

  .controls {
    display: inline-flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: #111;
    color: #ddd;
    border: 1px solid #444;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
  }

  button:active { transform: translateY(1px); }
  .paused { opacity: 0.6; }

  .cruiseOn {
    border-color: #888;
    box-shadow: 0 0 0 1px #666 inset;
  }
</style>
</head>

<body>

<canvas id="stars"></canvas>
<div id="bgAurora"></div>
<div id="bgTunnel"></div>
<div id="bgShade"></div>

<div id="container">
  <svg id="spinner" viewBox="-100 -100 200 200" aria-label="Yin Yang spinner" role="img">
    <defs>
      <filter id="warp" x="-30%" y="-30%" width="160%" height="160%">
        <feTurbulence id="turb" type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="2" />
        <feDisplacementMap id="disp" in="SourceGraphic" scale="0" />
      </filter>
    </defs>

    <g id="art">
      <circle id="outer" r="100" fill="white"/>

      <path id="half" d="
        M 0 -100
        A 100 100 0 0 1 0 100
        A 50 50 0 0 0 0 0
        A 50 50 0 0 1 0 -100
      " fill="black"/>

      <circle id="lobe1" cx="0" cy="-50" r="50" fill="white"/>
      <circle id="lobe2" cx="0" cy="50"  r="50" fill="black"/>

      <circle id="dot1" cx="0" cy="-42" r="14" fill="black"/>
      <circle id="dot2" cx="0" cy="42"  r="14" fill="white"/>
    </g>
  </svg>

  <div id="hud">
    <div>
      <strong>RPM:</strong>
      <span id="rpm">0.0</span>
      <span id="state"></span>
    </div>

    <div class="row">
      <input id="rpmSlider" type="range" min="0" max="600" step="1" value="0" />
      <span><strong>Target:</strong> <span id="rpmTarget">0</span></span>
    </div>

    <div class="controls">
      <button id="toggleBtn" type="button">Pause</button>
      <button id="resetBtn" type="button">Reset</button>
      <button id="brakeBtn" type="button">Brake</button>
      <button id="cruiseBtn" type="button">Cruise</button>
      <button id="modeBtn" type="button">Mode</button>
    </div>

    <div class="small">
      <strong>Mode:</strong> <span id="modeName"></span><br>
      <kbd>Space</kbd> start/stop · <kbd>↑</kbd>/<kbd>↓</kbd> speed · <kbd>R</kbd> reset ·
      <kbd>M</kbd> mode · <kbd>B</kbd> brake · <kbd>C</kbd> cruise<br>
      <span style="opacity:.8">
        <kbd>G</kbd> bg all · <kbd>A</kbd> aurora · <kbd>T</kbd> tunnel · <kbd>F</kbd> stars · <kbd>S</kbd> bg strobe
      </span>
    </div>
  </div>
</div>

<script>
  const spinner = document.getElementById("spinner");
  const art = document.getElementById("art");

  const outer = document.getElementById("outer");
  const half  = document.getElementById("half");
  const lobe1 = document.getElementById("lobe1");
  const lobe2 = document.getElementById("lobe2");
  const dot1  = document.getElementById("dot1");
  const dot2  = document.getElementById("dot2");

  const turb = document.getElementById("turb");
  const disp = document.getElementById("disp");

  const rpmEl = document.getElementById("rpm");
  const stateEl = document.getElementById("state");
  const slider = document.getElementById("rpmSlider");
  const rpmTargetEl = document.getElementById("rpmTarget");

  const toggleBtn = document.getElementById("toggleBtn");
  const resetBtn = document.getElementById("resetBtn");
  const brakeBtn = document.getElementById("brakeBtn");
  const cruiseBtn = document.getElementById("cruiseBtn");
  const modeBtn = document.getElementById("modeBtn");
  const modeNameEl = document.getElementById("modeName");

  const bgAurora = document.getElementById("bgAurora");
  const bgTunnel = document.getElementById("bgTunnel");
  const stars = document.getElementById("stars");
  const ctx = stars.getContext("2d", { alpha: true });

  // ----- STATE -----
  let angle = 0;
  let speed = 0;           // deg/sec
  let running = true;

  let targetRPM = 0;
  let autoRamp = true;
  let cruiseOn = false;

  let last = performance.now();
  let hue = 0;
  let t = 0;

  const steps = 24;
  const stepSize = 360 / steps;

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
  function rpmToDeg(rpm) { return rpm * 6; }
  const MAX_RPM = 600;

  // Intensity
  const INT = 0.75;

  // ----- UI THROTTLE / CACHES -----
  let uiLastWrite = 0;
  let lastShownRPM = "";
  let lastShownTarget = "";
  let lastSlider = -1;

  function writeTargetUI(rpm) {
    const rounded = Math.round(rpm);
    if (rounded !== lastSlider) {
      slider.value = String(rounded);
      lastSlider = rounded;
    }
    const s = String(rounded);
    if (s !== lastShownTarget) {
      rpmTargetEl.textContent = s;
      lastShownTarget = s;
    }
  }

  function writeRPMUI(rpmFloat) {
    const s = rpmFloat.toFixed(1);
    if (s !== lastShownRPM) {
      rpmEl.textContent = s;
      lastShownRPM = s;
    }
  }

  function updateColors() {
    outer.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
    half.setAttribute("fill", `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    lobe1.setAttribute("fill", `hsl(${((hue+90)%360+360)%360},100%,60%)`);
    lobe2.setAttribute("fill", `hsl(${((hue+270)%360+360)%360},100%,60%)`);
    dot1.setAttribute("fill", `hsl(${((hue+180)%360+360)%360},100%,60%)`);
    dot2.setAttribute("fill", `hsl(${(hue%360+360)%360},100%,60%)`);
  }

  function classicColors() {
    outer.setAttribute("fill", "white");
    half.setAttribute("fill", "black");
    lobe1.setAttribute("fill", "white");
    lobe2.setAttribute("fill", "black");
    dot1.setAttribute("fill", "black");
    dot2.setAttribute("fill", "white");
  }

  function setDotStroke(on) {
    if (on) {
      dot1.setAttribute("stroke", "white");
      dot1.setAttribute("stroke-width", "2");
      dot2.setAttribute("stroke", "black");
      dot2.setAttribute("stroke-width", "2");
    } else {
      dot1.removeAttribute("stroke");
      dot1.removeAttribute("stroke-width");
      dot2.removeAttribute("stroke");
      dot2.removeAttribute("stroke-width");
    }
  }

  function setRunning(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? "Pause" : "Start";
    stateEl.textContent = running ? "" : " (paused)";
    rpmEl.classList.toggle("paused", !running);
  }

  function setTargetRPM(rpm) {
    targetRPM = clamp(rpm, 0, MAX_RPM);
  }

  function setCruiseUI(on) {
    cruiseOn = on;
    cruiseBtn.classList.toggle("cruiseOn", on);
    cruiseBtn.textContent = on ? "Cruise: On" : "Cruise";
  }

  function cancelCruise() { if (cruiseOn) setCruiseUI(false); }

  function brake() {
    autoRamp = false;
    cancelCruise();
    setRunning(true);
    setTargetRPM(0);
  }

  function cruise() {
    if (!cruiseOn) {
      autoRamp = false;
      const currentRPM = speed / 6;
      setTargetRPM(Math.round(currentRPM));
      setCruiseUI(true);
    } else {
      setCruiseUI(false);
      autoRamp = true;
    }
  }

  function clearTrippyFX() {
    art.removeAttribute("filter");
    spinner.style.filter = "";
    spinner.style.mixBlendMode = "";
    spinner.style.transformOrigin = "50% 50%";
  }

  function resetAll() {
    angle = 0;
    speed = 0;
    hue = 0;
    t = 0;
    spinner.style.transform = "rotate(0deg)";

    autoRamp = true;
    cancelCruise();

    setRunning(true);
    setTargetRPM(0);

    modes[modeIndex].onEnter?.();

    writeTargetUI(targetRPM);
    writeRPMUI(0);
  }

  // ----- SPINNER MODES -----
  let modeIndex = 1;
  const modes = [
    { name: "Classic (B/W)", onEnter(){ clearTrippyFX(); setDotStroke(false); classicColors(); }, update(dt){} },
    {
      name: "Indexed Color (Stepped)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        hue = Math.round(hue / stepSize) * stepSize;
        updateColors();
      }
    },
    {
      name: "Outlined Eyes (Smooth Hue)",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); },
      update(dt){ hue += (speed * 0.02 * dt); updateColors(); }
    },
    {
      name: "Neon Glow Pulse",
      onEnter(){ clearTrippyFX(); setDotStroke(true); updateColors(); spinner.style.mixBlendMode = "screen"; },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
        const pulse = 0.5 + 0.5 * Math.sin(t * 2.2);
        const glow = clamp((rpm / 600) * 18 + pulse * 8, 0, 28);
        spinner.style.filter = `drop-shadow(0 0 ${glow.toFixed(1)}px hsl(${(hue%360+360)%360},100%,60%))`;
      }
    },
    {
      name: "Warp Field (Liquid)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); art.setAttribute("filter","url(#warp)"); },
      update(dt){
        hue += (speed * 0.018 * dt);
        updateColors();
        const rpm = speed / 6;
        const energy = rpm / 600;
        const wobble = 0.5 + 0.5 * Math.sin(t * 1.7);
        const bf = 0.010 + 0.012 * (0.35 + wobble) * energy;
        turb.setAttribute("baseFrequency", bf.toFixed(4));
        const scale = 2 + 28 * energy * (0.35 + wobble);
        disp.setAttribute("scale", scale.toFixed(1));
      }
    },
    {
      name: "Strobe Invert (Beat)",
      onEnter(){ clearTrippyFX(); setDotStroke(false); updateColors(); },
      update(dt){
        hue += (speed * 0.02 * dt);
        updateColors();
        const rpm = speed / 6;
