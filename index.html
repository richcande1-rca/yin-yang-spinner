<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Yin Yang — Multi-Mode Spinner</title>

<style>
  html, body {
    margin: 0;
    background: black;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, sans-serif;
    color: #ddd;
  }

  #container {
    position: relative;
    width: 420px;
    height: 420px;
  }

  @media (max-width: 520px) {
    #container { width: 320px; height: 320px; }
    #hud { bottom: -140px; }
    input[type="range"] { width: 210px; }
  }

  svg {
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
    transform-box: fill-box;
    will-change: transform, filter;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  #hud {
    position: absolute;
    bottom: -120px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    opacity: 0.88;
    user-select: none;
  }

  .row { margin-top: 6px; }
  input[type="range"] { width: 240px; }

  .small {
    font-size: 12px;
    opacity: 0.72;
    margin-top: 8px;
    line-height: 1.4;
  }

  kbd {
    background: #222;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 1px 5px;
  }

  .controls {
    display: inline-flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: #111;
    color: #ddd;
    border: 1px solid #444;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
  }

  button:active { transform: translateY(1px); }
  .paused { opacity: 0.6; }

  .cruiseOn {
    border-color: #888;
    box-shadow: 0 0 0 1px #666 inset;
  }
</style>
</head>

<body>
<div id="container">

  <svg id="spinner" viewBox="-100 -100 200 200" aria-label="Yin Yang spinner" role="img">
    <defs>
      <!-- "Trippy Warp" filter: turbulence drives displacement -->
      <filter id="warp" x="-30%" y="-30%" width="160%" height="160%">
        <feTurbulence id="turb" type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="2" />
        <feDisplacementMap id="disp" in="SourceGraphic" scale="0" />
      </filter>
    </defs>

    <g id="art">
      <circle id="outer" r="100" fill="white"/>

      <path id="half" d="
        M 0 -100
        A 100 100 0 0 1 0 100
        A 50 50 0 0 0 0 0
        A 50 50 0 0 1 0 -100
      " fill="black"/>

      <circle id="lobe1" cx="0" cy="-50" r="50" fill="white"/>
      <circle id="lobe2" cx="0" cy="50"  r="50" fill="black"/>

      <circle id="dot1" cx="0" cy="-42" r="14" fill="black"/>
      <circle id="dot2" cx="0" cy="42"  r="14" fill="white"/>
    </g>
  </svg>

  <div id="hud">
    <div>
      <strong>RPM:</strong>
      <span id="rpm">0.0</span>
      <span id="state"></span>
    </div>

    <div class="row">
      <input id="rpmSlider" type="range" min="0" max="600" step="1" value="0" />
      <span><strong>Target:</strong> <span id="rpmTarget">0</span></span>
    </div>

    <div class="controls">
      <button id="toggleBtn" type="button">Pause</button>
      <button id="resetBtn" type="button">Reset</button>
      <button id="brakeBtn" type="button">Brake</button>
      <button id="cruiseBtn" type="button">Cruise</button>
      <button id="modeBtn" type="button">Mode</button>
    </div>

    <div class="small">
      <strong>Mode:</strong> <span id="modeName"></span><br>
      <kbd>Space</kbd> start/stop · <kbd>↑</kbd>/<kbd>↓</kbd> speed · <kbd>R</kbd> reset ·
      <kbd>M</kbd> mode · <kbd>B</kbd> brake · <kbd>C</kbd> cruise
    </div>
  </div>

</div>

<script>
  const spinner = document.getElementById("spinner");
  const art = document.getElementById("art");

  const outer = document.getElementById("outer");
  const half  = document.getElementById("half");
  const lobe1 = document.getElementById("lobe1");
  const lobe2 = document.getElementById("lobe2");
  const dot1  = document.getElementById("dot1");
  const dot2  = document.getElementById("dot2");

  const turb = document.getElementById("turb");
  const disp = document.getElementById("disp");

  const rpmEl = document.getElementById("rpm");
  const stateEl = document.getElementById("state");
  const slider = document.getElementById("rpmSlider");
  const rpmTargetEl = document.getElementById("rpmTarget");

  const toggleBtn = document.getElementById("toggleBtn");
  const resetBtn = document.getElementById("resetBtn");
  const brakeBtn = document.getElementById("brakeBtn");
  const cruiseBtn = document.getElementById("cruiseBtn");
  const modeBtn = document.getElementById("modeBtn");
  const modeNameEl = document.getElementById("modeName");

  // ----- STATE -----
  let angle = 0;           // degrees
  let speed = 0;           // deg/sec (actual)
  let running = true;

  let targetRPM = 0;       // physics target (authoritative)
  let autoRamp = true;     // ramps targetRPM upward to max
  let cruiseOn = false;    // locks current RPM; pressing again resumes autoRamp

  let last = performance.now();
  let hue = 0;
  let t = 0;               // "time" accumulator for effects

  const steps = 24;
  const stepSize = 360 / steps;

  function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
  function rpmToDeg(rpm) { return rpm * 6; } // 1 RPM = 6 deg/sec
  const MAX_RPM = 600;

  // ----- UI THROTTLE / CACHES -----
  let uiLastWrite = 0;
  let lastShownRPM = "";
  let lastShownTarget = "";
  let lastSlider = -1;

  function writeTargetUI(rpm) {
    const rounded = Math.round(rpm);
    if (rounded !== lastSlider) {
      slider.value = String(rounded);
      lastSlider = rounded;
    }
    const s = String(rounded);
    if (s !== lastShownTarget) {
      rpmTargetEl.textContent = s;
      lastShownTarget = s;
    }
  }

  function writeRPMUI(rpmFloat) {
    const s = rpmFloat.toFixed(1);
    if (s !== lastShownRPM) {
      rpmEl.textContent = s;
      lastShownRPM = s;
    }
  }

  function hsl(h) {
    return `hsl(${(h % 360 + 360) % 360},100%,60%)`;
  }

  function updateColors() {
    outer.setAttribute("fill", hsl(hue));
    half.setAttribute("fill", hsl(hue + 180));
    lobe1.setAttribute("fill", hsl(hue + 90));
    lobe2.setAttribute("fill", hsl(hue + 270));
    dot1.setAttribute("fill", hsl(hue + 180));
    dot2.setAttribute("fill", hsl(hue));
  }

  function classicColors() {
    outer.setAttribute("fill", "white");
    half.setAttribute("fill", "black");
    lobe1.setAttribute("fill", "white");
    lobe2.setAttribute("fill", "black");
    dot1.setAttribute("fill", "black");
    dot2.setAttribute("fill", "white");
  }

  function setDotStroke(on) {
    if (on) {
      dot1.setAttribute("stroke", "white");
      dot1.setAttribute("stroke-width", "2");
      dot2.setAttribute("stroke", "black");
      dot2.setAttribute("stroke-width", "2");
    } else {
      dot1.removeAttribute("stroke");
      dot1.removeAttribute("stroke-width");
      dot2.removeAttribute("stroke");
      dot2.removeAttribute("stroke-width");
    }
  }

  function setRunning(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? "Pause" : "Start";
    stateEl.textContent = running ? "" : " (paused)";
    rpmEl.classList.toggle("paused", !running);
  }

  // Physics target setter (no DOM spam)
  function setTargetRPM(rpm) {
    targetRPM = clamp(rpm, 0, MAX_RPM);
  }

  function setCruiseUI(on) {
    cruiseOn = on;
    cruiseBtn.classList.toggle("cruiseOn", on);
    cruiseBtn.textContent = on ? "Cruise: On" : "Cruise";
  }

  function cancelCruise() {
    if (cruiseOn) setCruiseUI(false);
  }

  function brake() {
    autoRamp = false;
    cancelCruise();
    setRunning(true);
    setTargetRPM(0);
  }

  function cruise() {
    if (!cruiseOn) {
      autoRamp = false;
      const currentRPM = speed / 6;
      setTargetRPM(Math.round(currentRPM));
      setCruiseUI(true);
    } else {
      setCruiseUI(false);
      autoRamp = true;
    }
  }

  function clearTrippyFX() {
    // Remove any leftover filter / CSS effects when changing modes
    art.removeAttribute("filter");
    spinner.style.filter = "";
    spinner.style.mixBlendMode = "";
    spinner.style.transformOrigin = "50% 50%";
  }

  function resetAll() {
    angle = 0;
    speed = 0;
    hue = 0;
    t = 0;
    spinner.style.transform = "rotate(0deg)";

    autoRamp = true;
    cancelCruise();

    setRunning(true);
    setTargetRPM(0);

    modes[modeIndex].onEnter?.();

    // Force UI to reflect reset immediately
    writeTargetUI(targetRPM);
    writeRPMUI(0);
  }

  // ----- MODES -----
  let modeIndex = 1;
  const modes = [
    {
      name: "Classic (B/W)",
      onEnter() {
        clearTrippyFX();
        setDotStroke(false);
        classicColors();
      },
      update(dt) {}
    },
    {
      name: "Indexed Color (Stepped)",
      onEnter() {
        clearTrippyFX();
        setDotStroke(false);
        updateColors();
      },
      update(dt) {
        hue += (speed * 0.02 * dt);
        hue = Math.round(hue / stepSize) * stepSize;
        updateColors();
      }
    },
    {
      name: "Outlined Eyes (Smooth Hue)",
      onEnter() {
        clearTrippyFX();
        setDotStroke(true);
        updateColors();
      },
      update(dt) {
        hue += (speed * 0.02 * dt);
        updateColors();
      }
    },
    {
      name: "Neon Glow Pulse",
      onEnter() {
        clearTrippyFX();
        setDotStroke(true);
        updateColors();
        spinner.style.mixBlendMode = "screen";
      },
      update(dt) {
        hue += (speed * 0.02 * dt);
        updateColors();

        // Glow amount ties to RPM + a slow pulse
        const rpm = speed / 6;
        const pulse = 0.5 + 0.5 * Math.sin(t * 2.2);
        const glow = clamp((rpm / 600) * 18 + pulse * 8, 0, 28);
        // keep it simple: drop-shadow is GPU friendly on most devices
        spinner.style.filter = `drop-shadow(0 0 ${glow.toFixed(1)}px ${hsl(hue)})`;
      }
    },
    {
      name: "Warp Field (Liquid)",
      onEnter() {
        clearTrippyFX();
        setDotStroke(false);
        updateColors();
        art.setAttribute("filter", "url(#warp)");
      },
      update(dt) {
        hue += (speed * 0.018 * dt);
        updateColors();

        // Animate turbulence & displacement scale
        const rpm = speed / 6;
        const energy = rpm / 600;           // 0..1
        const wobble = 0.5 + 0.5 * Math.sin(t * 1.7);

        // Small baseFrequency changes look like "living fluid"
        const bf = 0.010 + 0.012 * (0.35 + wobble) * energy;
        turb.setAttribute("baseFrequency", bf.toFixed(4));

        // Scale controls warp intensity
        const scale = 2 + 28 * energy * (0.35 + wobble);
        disp.setAttribute("scale", scale.toFixed(1));
      }
    },
    {
      name: "Strobe Invert (Beat)",
      onEnter() {
        clearTrippyFX();
        setDotStroke(false);
        updateColors();
      },
      update(dt) {
        hue += (speed * 0.02 * dt);
        updateColors();

        const rpm = speed / 6;
        const beatHz = 2 + 10 * (rpm / 600);         // faster when spinning faster
        const strobe = (Math.sin(t * Math.PI * 2 * beatHz) > 0.4);

        // Invert pops on/off; plus a tiny zoom wobble
        const wob = 1 + 0.012 * Math.sin(t * 3.3);
        spinner.style.filter = strobe ? "invert(1) contrast(1.15)" : "contrast(1.05)";
        spinner.style.transform = `rotate(${angle}deg) scale(${wob.toFixed(4)})`;
      }
    }
  ];

  function applyMode(i) {
    modeIndex = (i + modes.length) % modes.length;
    modeNameEl.textContent = modes[modeIndex].name;
    modes[modeIndex].onEnter?.();
  }

  function nextMode() { applyMode(modeIndex + 1); }

  // ----- UI EVENTS -----
  slider.addEventListener("input", () => {
    cancelCruise();
    autoRamp = false;
    setTargetRPM(Number(slider.value));
    writeTargetUI(targetRPM);
  });

  toggleBtn.addEventListener("click", () => setRunning(!running));
  resetBtn.addEventListener("click", resetAll);
  brakeBtn.addEventListener("click", brake);
  cruiseBtn.addEventListener("click", cruise);
  modeBtn.addEventListener("click", nextMode);

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") {
      e.preventDefault();
      setRunning(!running);
      return;
    }
    if (e.key === "m" || e.key === "M") { nextMode(); return; }
    if (e.key === "r" || e.key === "R") { resetAll(); return; }
    if (e.key === "b" || e.key === "B") { brake(); return; }
    if (e.key === "c" || e.key === "C") { cruise(); return; }

    if (e.key === "ArrowUp") {
      cancelCruise();
      autoRamp = false;
      setTargetRPM(targetRPM + 5);
      writeTargetUI(targetRPM);
      return;
    }

    if (e.key === "ArrowDown") {
      cancelCruise();
      autoRamp = false;
      setTargetRPM(targetRPM - 5);
      writeTargetUI(targetRPM);
      return;
    }
  });

  // ----- ANIMATION LOOP -----
  function tick(now) {
    const dt = (now - last) / 1000;
    last = now;
    t += dt;

    if (running) {
      // Auto ramp targetRPM upward to max over ~10 seconds (0 -> 600)
      if (autoRamp) {
        cancelCruise();
        const rampRate = MAX_RPM / 10; // RPM per second
        setTargetRPM(targetRPM + rampRate * dt);
        if (targetRPM >= MAX_RPM) autoRamp = false;
      }

      const targetSpeed = rpmToDeg(targetRPM);

      // REAL BRAKE BITE:
      // accel is gentle; decel is stronger (feels like brakes)
      const accel = 360;  // deg/sec^2
      const decel = 900;  // deg/sec^2  <-- stronger than accel
      const maxAccel = (targetSpeed < speed) ? decel : accel;

      const delta = targetSpeed - speed;
      const step = Math.sign(delta) * Math.min(Math.abs(delta), maxAccel * dt);
      speed += step;

      angle = (angle + speed * dt) % 360;

      // Most modes use rotation only; Strobe mode overrides transform inside its update()
      if (modes[modeIndex].name !== "Strobe Invert (Beat)") {
        spinner.style.transform = `rotate(${angle}deg)`;
      }

      writeRPMUI(speed / 6);
      modes[modeIndex].update?.(dt);
    }

    // UI target updates (throttle to ~20fps)
    if (now - uiLastWrite > 50) {
      uiLastWrite = now;
      writeTargetUI(targetRPM);
    }

    requestAnimationFrame(tick);
  }

  // init
  applyMode(modeIndex);
  resetAll(); // cold start + auto ramp
  requestAnimationFrame(tick);
</script>

</body>
</html>
